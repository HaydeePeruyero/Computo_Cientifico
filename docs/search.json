[{"path":"index.html","id":"temas-selectos-de-análisis-numérico-y-computación-científica-computo-científico-para-el-análisis-de-datos","chapter":"Sección 1 Temas Selectos de Análisis Numérico y Computación Científica: Computo científico para el análisis de datos","heading":"Sección 1 Temas Selectos de Análisis Numérico y Computación Científica: Computo científico para el análisis de datos","text":"Curso del posgrado conjunto en Ciencias Matemáticas PCCM UNAM UMICH 2024-2","code":""},{"path":"index.html","id":"temario","chapter":"Sección 1 Temas Selectos de Análisis Numérico y Computación Científica: Computo científico para el análisis de datos","heading":"1.1 Temario","text":"Git y GithubGit y GithubShellShellPythonPythonSQLSQLPower BIPower BIRREstadística multivariadaEstadística multivariadaAnálisis de regresiónAnálisis de regresión","code":""},{"path":"index.html","id":"referencias","chapter":"Sección 1 Temas Selectos de Análisis Numérico y Computación Científica: Computo científico para el análisis de datos","heading":"1.2 Referencias","text":"[1] Arnold, Jeremey. Learning Microsoft Power BI, O’Reilly Media, Inc.[2] Beaulieu, Alan. Learning SQL, O’Reilly Media, Inc., 2020[3] Bruce, Peter, Bruce, Andrew Gedeck, Peter. Practical Statistics Data Scientists, O’Reilly Media, Inc., 2020.[4] Crawley, Michael J. R book. John Wiley & Sons, 2012.[5] McKinney, Wes. Python data analysis. O’Reilly Media, Inc., 2022.[6] Nelli, Fabio. Python Data Analytics, Apress.[7] Wade, Ryan. Advanced Analytics Power BI R Python, Apress.[8] Wickham, Hadley, Garrett Grolemund. R data science: import, tidy, transform, visualize, \nmodel data. O Reilly Media, Inc., 2016.[9] Zamora Saiz, Alfonso, et al. Introduction Data Analysis R: Hands-Coding, Data Mining,\nVisualization Statistics Scratch., Springer (2020).[10] Software Carpentry, Unix Shell, https://swcarpentry.github.io/shell-novice/","code":""},{"path":"index.html","id":"material-interesante","chapter":"Sección 1 Temas Selectos de Análisis Numérico y Computación Científica: Computo científico para el análisis de datos","heading":"1.3 Material interesante","text":"Bookdown.Software Carpentry.GitWhy GitR Markdown CookbookSTHDAYaRrr! Pirate’s Guide RLearn ggplot2 Using Shiny AppGgplot2: Elegant Graphics Data Analysis\nVersión online\nVersión onlineUse R! Colección SpringerLattice: Multivariate Data Visualization RR Graphics cookbook","code":""},{"path":"index.html","id":"datacamp","chapter":"Sección 1 Temas Selectos de Análisis Numérico y Computación Científica: Computo científico para el análisis de datos","heading":"1.4 DataCamp","text":"","code":""},{"path":"shell.html","id":"shell","chapter":"Sección 2 Shell","heading":"Sección 2 Shell","text":"Descargar git bash para Windows o seguir las instrucciones de Software carpentries para otros sistemas operativos.\nBasado en la lección de carpentries","code":""},{"path":"shell.html","id":"navegar-en-archivos-y-directorios","chapter":"Sección 2 Shell","heading":"2.1 Navegar en archivos y directorios","text":"Cuando abrimos una terminal por primera vez, vamos ver un prompt (usualmente es $) que nos indica que esta esperando los comandos. Después de teclear los comandos, debemos siempre presionar Enter.Para listar lo que hay en un directorio usamos el comando ls.Al comando ls le podemos agregar unos adjetivos para hacer más comprensible su lectura. Por ejemplo, la opción -F nos indica si es una carpeta, un archivo, un link, etc.Con la opción --help podemos acceder la ayuda del comando.Otras opciones que nos ayudan entender la información que tenemos en el archivo son -lh, nos muestra los permisos del archivo o carpeta, tamaño, propietario, fecha, nombre. La opción ls -nos muestra los archivos ocultos.Ejercicio: ¿Qué hace la opción -l? ¿Cómo podemos listar en orden de creación e inverso?Con el comando ls también podemos listar los archivos de cualquier otro directorio, solo debemos indicarle el directorio después del comando:El comando ls solo nos esta listando lo que hay en los directorios. Si nos queremos mover otro directorio, lo podemos hacer con el comando cd y especificando el directorio.El comando pwd nos da la ruta en la que estamos.Para movernos un directorio arriba, colocamos después de cd dos puntos.Si colocamos los dos puntos, el comando cd nos lleva al /home/.Otra forma de movernos de un directorio otro es especificando la ruta absoluta, es decir la ruta completa de donde queremos movernos.Ejercicio: ¿Qué es una ruta relativa?Otro opción útil que podemos usar con el comando cd es -.Ejercicio: ¿donde nos lleva cd -? y si volvemos colocar cd - ¿donde nos lleva? ¿Cuál es la diferencia entre cd .. y cd -?La tilde ~, shell la interpreta como el home del usuario, entonces si colocamos cd ~/directorio sería lo mismo que /home/directorio. Por ejemplo:es lo mismo queEjercicio: Supongamos que tenemos el siguiente árbol de datos en nuestra computadora y que estamos en /Users/thing/. ¿Si colocamos en la terminal ls -F ../backup que nos mostrará?Ejercicio: Explora las opciones -s y -S. ¿Hay diferencia entre mayúsculas y minúsculas?La tecla Tab nos ayuda completar los comando/rutas. Si la presionamos dos veces nos mostrará todas las posibles opciones.","code":"$ $ lsDocuments  Downloads  Music  Pictures  Videos$ ls -Fej.txt  Git/  PBI/  Python/  R/  Shell/  SQL/$ ls --help$ ls - F Shell $ cd Shell\n$ lsdata/  ej1.txt  ejercicios/$ pwd/d/Users/hayde/Documents/Curso_Comp_Cien/Shell$ cd ..$ cd $ cd /d/Users/hayde/Documents/Curso_comp_Cien$ cd ~/Desktop$ cd /c/Users/hayde/Desktop"},{"path":"shell.html","id":"manipulación-de-archivos-y-directorios","chapter":"Sección 2 Shell","heading":"2.2 Manipulación de archivos y directorios","text":"Para crear directorios/carpetas desde la línea de comandos usamos el comando mkdir nombre. Vamos crear la carpeta del curso. Es recomendable usar espacios en nombres de carpetas ni archivos.El comando mkdir nos permite crear más de un directorio y directorios anidados usando la opción -p.Para listar toda la estructura de nuestras carpetas podemos usar la opción -FR en el comando ls.Otra opción útil para listar toda la estructura de nuestro directorio es la opción tree, viene instalado por default en los sistemas operativos. En Windows, si se instalo git/bash se puede usar con tree.com.Nota: Para descargar tree y que podamos ver la estructura de árbol con archivos y carpetas hacer lo siguiente:Ir la página y descargar la versión que dice binaries.Ir la página y descargar la versión que dice binaries.Extraer lo que hay en la carpeta bin.Extraer lo que hay en la carpeta bin.Copiar el archivo tree.exe la carpeta /c/Program_files/Git/usr/bin/.Copiar el archivo tree.exe la carpeta /c/Program_files/Git/usr/bin/.Para probarlo, solo colocar en la terminal tree ruta.Para probarlo, solo colocar en la terminal tree ruta.Para crear un archivo usando el editor nano (si fue el que configuraron), se usa el comando nano nombre.extension.\nVamos crear un archivo de prueba en la carpeta ejercicios y escribamos algo en el archivo.Para guardar y salir del editor, usamos los comandos Ctrl+O o Ctrl+X seguido de Yes y enter.Si en el archivo guardaron nada, entonces se creara. Una forma de crear archivos sin abrirlos es con el comando touch.Si checamos con ls -l los archivos o rutas que creamos, veremos que tienen ningún tamaño.Para mover archivos o renombrarlos, usamos el comando mv seguido del archivo que queremos mover/renombrar y la ruta donde lo moveremos o el nuevo nombre del archivo.Lo anterior esta cambiándole el nombre al archivo ej2.txt por ejercicio2.txt.Si estamos en un directorio y queremos mover un archivo de otro directorio al directorio actual, podemos hacerlo especificando como primer argumento la ruta y nombre del archivo mover y como segundo argumento un punto ..O especificando la ruta completa.Para copiar archivos, usamos el comando cp seguido por la ruta del archivo copiar y la ruta del archivo donde se copiará. Movámonos la carpeta Shell/ejercicios.Si usamos la opción -r (recursivo) en el comando cp podemos copiar un directorio completo y todos sus elementos.Ejercicio: ¿Cual es el output de la siguiente colección de comandos?Para borrar archivos usamos el comando rm, hay que tener cuidado cuando lo usemos ya que borra definitivamente los archivos o carpetas.Una forma segura de borrar archivos es usando la opción -, con esto nos saldrá un mensaje preguntando si en verdad deseamos borrar el archivo. Para confirmar debemos colocar y.Si queremos borrar una carpeta, debemos hacerlo con la opción -r, de lo contrario obtendremos un error.Para mover/copiar/eliminar multiples archivos la vez, podemos enumerarlos todos o usar comodines/patrones que sigan estos elementos. Supongamos que tenemos una lista de archivos todos con terminación .txt, entonces para borrarlos podemos usar rm *.txt. El * nos indica todo lo que este antes de .txt.Otro comodín que podemos usar es ?, pero este denota solo 1 espacio. Por ejemplo:Ejercicio: Supon que en el directorio data tienes dos archivos. ¿Cuál de los siguientes comandos te daría como resultado: ethane.pdb methane.pdb.ls *t*ane.pdbls *t*ane.pdbls *t?ne.*ls *t?ne.*ls *t??ne.pdbls *t??ne.pdbls ethane.*ls ethane.*","code":"$ mkdir Curso_Comp_Cien$ mkdir -p Curso_Comp_Cien/Shell/data Curso_Comp_Cien/Shell/ejercicios$ ls -FR$ tree.com$ cd Curso_Comp_Cien/\n$ nano prueba.txt$ cd Shell/ejercicios\n$ touch ../ej1.txt ej2.txt ../data/ej3.csv ../data/ej4.csv$ pwd\n$ mv ej2.txt ejercicio2.txt$ mv ../ej1.txt .$ cd ..\n$ mv data/ej3.csv ejercicios/.$ pwd\n$ cp ejercicio2.txt ../ej2.txt\n$ ls -FR$ cd ejercicios\n$ cp -r ../data .$ pwd/Users/haydee/Curso$ ls -Farchivo.txt carpeta/$ mkdir carpeta2\n$ mv archivo.txt carpeta2/\n$ cd carpeta2\n$ cp archivo.txt ../carpeta/archivo_respaldo.txt\n$ cd ..\n$ ls -FR$ cd Shell\n$ rm ejercicios/ejercicio2.txt\n$ ls ejercicios/$ rm -i /data/ej3.csvrm: remove regular empty file 'ej3.txt'?$ rm data$ rm -r data$ cd Shell/\n$ touch prueba1.txt prueba2.txt prueba3.txt prueba4.txt prueba5.txt\n$ rm *.txt$ cd Shell/\n$ touch prueba1.txt prueba2.txt prueba3.txt prueba4.txt prueba5.txt\n$ rm prueba?.txt$ cd Shell/\n$ touch prueba1.txt prueba2.txt prueba3.txt prueba4.txt prueba5.txt\n$ rm prue???.txt"},{"path":"shell.html","id":"tuberías-y-filtros","chapter":"Sección 2 Shell","heading":"2.3 Tuberías y filtros","text":"Vamos usar los archivos de prueba de la lección de Shell de Software Carpentry. Descargarlos en el directorio que creamos que se llama Shell.Vamos explorar los archivos que están en la carpeta excercise-data/alkanes. Para contar cuantos palabras, líneas o caracteres tiene un archivo, usamos el comando wc que viene de word count.El primer número es el número de líneas del archivo, el segundo la cantidad de palabras y el tercero la cantidad de caracteres.Si usamos alguna de los comodines, por ejemplo *.pdb con el comando wc, nos va regresar la información de todos los archivos.Notemos que en la última fila tenemos los totales de todos los archivos. Accedamos la ayuda del comando con help.Ejercicio: ¿Cuál opción nos permite extraer solo la cantidad de líneas del archivo?Si por error olvidamos colocar el nombre del archivo o cualquier otra cosa después del comando, la consola se quedará esperando una instrucción, para salir de esto basta presionar Ctrl+C.Ya sabemos como extraer cierta información de nuestros archivos, pero supongamos que queremos guardarlo ahora en algún otro archivo para después analizarlo. El símbolo > redirige el resultado de los comandos usados algún archivo.Para solo visualizar el contenido de un archivo sin entrar al editor de texto, podemos usar el comando cat seguido del nombre del archivo.Otro comando que puede resultar más útil para mostrar el contenido de un archivo es less, la diferencia con cat es que este último muestra todo el contenido en la pantalla, lo cual puede dificultar su lectura e inspección, mientras que less muestra una parte del contenido y de forma ordenada, si queremos seguir viendo el contenido podemos usar la tecla de espacio, b y para salir usamos la letra q.Ya guardamos la información de la cantidad de líneas, pero supongamos que queremos saber cual archivo tiene la mayor cantidad de líneas o menor. Para hacer esto nos sirve el comando sort.Si sort le agregamos la opción -n, nos los ordena en numericamente en lugar de alfabeticamente.Ejercicio: De los archivos que están en la carpeta alkane, ¿cuál tiene la menor cantidad de líneas?También podemos redirigir esta información otro archivo y de ahí extraer la información.El comando head nos ayuda extraer las primeras n líneas de nuestro archivo. Por ejemplo, para extraer la primera línea del archivo lineas_ordenadas.txt y así saber cual archivo tenía la menor cantidad de líneas usaríamos head -n 1.El comando echo nos ayuda imprimir en la consola caracteres.Ejercicio: Realiza las siguientes instrucciones dos veces cada una. Explora las diferencias. ¿Qué hace el operador >>?El comando tail es similar al comando head, nos muestra las últimas n filas del archivo.Ejercicio: Considera el archivo /exercise-data/animal-counts/animals.csv. Después de aplicar los siguientes dos comandos, ¿qué hay en el archivo animals-subset.csv?","code":"$ lscubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb$ wc cubane.pdb20  156 1158 cubane.pdb$ wc *.pdb$ wc --help$ wc -l *.pdb$ wc -l *.pdb > lineas.txt$ cat lineas.txt$ cd ..\n$ sort numbers.txt$ sort -n numbers.txt$ sort -n lineas.txt > lineas_ordenadas.txt$ head -n 1 lineas_ordenadas.txt$ echo Hola$ echo hola > test1.txt$ echo hola >> test2.txt$ head -n 3 animals.csv > animals-subset.csv\n$ tail -n 2 animals.csv >> animals-subset.csv"},{"path":"shell.html","id":"tuberías","chapter":"Sección 2 Shell","heading":"2.3.1 Tuberías","text":"Además de redirigir los output de los comandos que hemos ocupado, también podríamos anidarlos y al final mandarlo un archivo. Para hacer esto se usan tuberías y su símbolo es |. Por ejemplo:En esta instrucción le estamos diciendo la consola que primero nos ordene lo que hay en el archivo líneas en orden númerico y después que nos muestre la primera línea. De esta forma nos evitamos por ejemplo el haber creado el archivo lineas_ordenadas.txt.Podemos anidar varias instrucciones la vez. Por ejemplo, podríamos pedirle la consola la cantidad de líneas de los archivos *.pdb, pedirle que las ordene numericamente y después que extraiga la primera línea.Ejercicio: De los archivos que están en la carpeta alkanes, obten los 3 archivos con la menor cantidad de líneas.Ejercicio: Explora el archivo exercise-data/animals-counts/animals.csv. ¿Cuál será el resultado de la siguiente instrucción?El comando cut nos ayuda extrar/cortar ciertas columnas de nuestros archivos. Por ejemplo, cut -d , -f 2 archivo nos está indicando que del archivo queremos cortar por caracteres , (eso hace -d ,) y que queremos extraer la segunda columna (-f 2).Si quisieramos extraer los animales únicos de ese archivo, podemos usar el comando uniq.Ejercicio: ¿Porqué se necesita colocar el sort antes del uniq?Ejercicio: Si quisiéramos ver cuantos animales hay de cada tipo, ¿que instrucción tendríamos que usar?","code":"$ sort -n lineas.txt | head -n 1$ wc -l *.pdb | sort -n | head -n 1$ cat animals.csv | head -n 5 | tail -n 3 | sort -r > final.txt$ cut -d , -f 2 animals.csv$ cut -d , -f 2 animals.csv | sort | uniq"},{"path":"shell.html","id":"ciclos","chapter":"Sección 2 Shell","heading":"2.4 Ciclos","text":"Los ciclos nos ayudan repetir comandos o un conjunto de comandos para cada elemento de una lista. La estructura del ciclo es como sigue:La palabra indica el comienzo del ciclo, la palabra nos indica que es lo que se va ejecutar y su comienzo y la palabra done indica el fin del ciclo.Exploremos lo que hay en la carpeta ~/Shell/shell-lesson-data/exercise-data/creatures. Listemos las primeras 5 filas de cada archivo.Supongamos que queremos ver la clasificación de cada especie que se encuentra en la segunda línea de cada archivo. Una forma de hacerlo es con head -n 2, pero de esta forma también estamos viendo su nombre común, entonces vamos hacerlo con un ciclo. Lo primero que tendríamos que hacer es usar justo head -n 2 y al resultado de esto, si le pedimos la última línea ya solo veríamos la clasificación, entonces usamos un tail -n 1.Notemos que cuando empezamos teclear nuestro ciclo, el prompt cambia de $ >, esto indica que está esperando que continuemos el ciclo. También podemos usar ; para continuar las instrucciones en una misma fila.Dentro de los ciclos, las variables las mandamos llamar con $, en el ejemplo, cuando ocupamos $filename estamos mandando llamar la variable filename que definimos al inicio del ciclo. Es muy usual también encerrar entre llaves los nombres de las variables para delimitar el nombre, en el ejemplo, $filename sería equivalente ${filename}.Ejercicio: Crea un ciclo que muestre en pantalla (echo) todos los números del 0 al 9.Ejercicio: Ve la carpeta shell-lesson-data/exercise-data/alkanes y lista lo que hay.\n1) ¿Cuál es el output del siguiente código?¿Y de este código?Explica las diferencias.Ejercicio: En el directorio shell-lesson-data/exercise-data/alkanes, ¿cuál sería el output del siguiente código?Y si en lugar de c* usamos c?Dentro de un ciclo también podemos pedir guardar archivos.Ejercicio: Explora el siguiente código. ¿Cuál es el efecto de guardar en este ciclo?¿Cuál sería la diferencia si usamos ahora >>?Ejercicio: Crea un ciclo que muestre las últimas 20 líneas de cada archivo en la carpeta creatures.Como ya mencionamos, es recomendable usar espacios ni caracteres especiales en nombres de archivos o carpetas. Si fuera el caso de que nuestros archivos tienen espacios, entonces deberíamos pasarlos al ciclo encerrados entre comillas los nombres. Por ejemplo, supongamos que tenemos los archivos archivo 1.txt y archivo 2.txt. Para leerlos en el ciclo tendríamos que usar la siguiente sintaxis.Supongamos que queremos modificar nuestros archivos que se encuentran en la carpeta creatures pero que antes queremos respaldarlos en otros archivos llamados original-basilisk.dat, original-unicorn.dat y original-minotaur.dat. Una forma de hacerlo sería copiarlos nuevos archivos con esos nombres, pero si lo queremos hacer manualmente, ¿qué pasa si usamos el siguiente código?Esto nos va dar un error porque el comando cp estaría esperando que original- sea una carpeta y lo es, existe esa carpeta. Entonces lo que podemos hacer es usar un ciclo.Ejercicio: Crea un ciclo que copie los dos archivos dos nuevos archivos llamados original-basilisk.dat, original-unicorn.dat y original-minotaur.dat.El comando cp nos muestra en pantalla ningún output. Si quisieramos ver que en efecto se esta realizando la copia de estos archivos podemos usar el comando echo y pedir que nos diga como “se copio el archivo $filename”. Usar echo de esta forma es una buena práctica de realizar lo que se llama debugging.Ejercicio: Supongamos que queremos previsualizar los comandos que el siguiente ciclo va realizar en lugar de correrlo primero para asegurarnos de que está haciendo lo que queremos.¿Cuál de los siguientes dos códigos sería el correcto para revisar los comando ejecutarse con el ciclo?Corre los dos códigos y explora el contenido del archivo .pdb.Supongamos que queremos crear una estructura de directorios como sigue, para cada compuesto y cada temperatura queremos una carpeta para ir guardando ahí sus resultados, y que cada carpeta se llame compuesto-temperatura, ¿cómo podemos hacer esto? Una opción son los ciclos anidados.Algunos comandos útiles para ver el historial de comadnos.history nos muestra el historial de comandos.history nos muestra el historial de comandos.Ctrl+R nos muestra la leyenda reverse--search, esto indica que está esperando que nosotros coloquemos una palabra y buscará por el último comando con esa palabra.Ctrl+R nos muestra la leyenda reverse--search, esto indica que está esperando que nosotros coloquemos una palabra y buscará por el último comando con esa palabra.history + !123 nos repetirá el comando !123 del historial.history + !123 nos repetirá el comando !123 del historial.!! nos muestra el último comando usado.!! nos muestra el último comando usado.!$ nos regresa la última palabra del último comando.!$ nos regresa la última palabra del último comando.Ejercicio: En la carpeta norht-pacific-gyre se encuentran dos scripts (.sh) y una lista de archivos. Esta lista de archivos tiene terminaciones , B y en el caso de que la terminación sea Z significa que el archivo está corrupto.¿Cómo podrías darte cuenta que los archivos con terminación Z están corruptos?Supongamos que queremos ejecutar el script llamado goostats.sh, este script necesita recibir dos cosas, el archivo de entrada y el nombre del archivo de salida. Supongamos que queremos correr este script para todos los archivos con terminación y B y que queremos que los archivos de salida se llamen stats-$datafile.Crea un ciclo que te muestre en pantalla el nombre del archivo usar como input.Crea un ciclo que te muestre en pantalla el nombre del archivo usar como input.Crea un ciclo que te muestre en pantalla el nombre del archivo de salida con el formato indicado. Pero quieres asegurarte que para el archivo input sea el nombre correcto el del archivo de salida.Crea un ciclo que te muestre en pantalla el nombre del archivo de salida con el formato indicado. Pero quieres asegurarte que para el archivo input sea el nombre correcto el del archivo de salida.Crea un ciclo que muestre los comandos usarse para correr el script con los archivos de entrada y de salida del paso 2 y 3. Para correr un script como se indica, se usa el comando bash nombre_archivo.sh input output.Crea un ciclo que muestre los comandos usarse para correr el script con los archivos de entrada y de salida del paso 2 y 3. Para correr un script como se indica, se usa el comando bash nombre_archivo.sh input output.Agrega un echo $datafile para saber en que archivo va tu ciclo.Agrega un echo $datafile para saber en que archivo va tu ciclo.","code":"for elemento in lista\ndo \n  operacion/comando $elemento\ndone$ head -n 5 basilisk.dat minotaur.dat unicorn.dat$ for filename in *.dat\n> do\n>   echo $filename\n>   head -n 2 $filename | tail -n 1\n> done$ for datafile in *.pdb\n> do\n>     ls *.pdb\n> done$ for datafile in *.odb\n> do \n>     ls $datafile\n> done$ for filename in c*\n> do\n>     ls $filename\n> done$ for alkanes in *.pdb\n> do\n>     echo $alkanes\n>     cat $alkanes > alkanes.pdb\n> done$ for filename in \"archivo 1.txt\" \"archivo 2.txt\"\n> do\n>     head -n20 \"$filename\" | tail -n5 \n> done$ cp *.dat original-*.dat$ for filename in *.dat\n> do\n>     echo cp $filename original-$filename\n> done$ for filename in *.pdb\n> do\n>     cat $filename >> all.pdb\n> done# Versión 1\n$ for filename in *.pdb\n> do\n>     echo cat $filename >> all.pdb\n> done# Versión 2\n$ for filename in *.pdb\n> do\n>    echo \"cat $filename >> all.pdb\"\n> done$ for species in cubane ethane methane \n> do\n>     for temperature in 25 30 37 40\n>     do\n>         mkdir $species-$temperature\n>     done\n> done"},{"path":"shell.html","id":"scripts","chapter":"Sección 2 Shell","heading":"2.5 Scripts","text":"Los scripts nos ayudan repetir los comandos sobre listas de archivos. Supongamos que existen ciertos comando que siempre repetimos, vamos guardarlos en un archivo para con un solo comando ejecutar esa lista de comandos.Vamos al directorio alkanes. Supongamos que siempre queremos extraer las líneas de la 11 la 15 de cada archivo. Por ejemplo, una forma en la que lo hacemos es:Vamos escribir eso en un archivo:Guardemos eso. Para ejecutarlo bastaría correr lo siguiente:Supongamos que queremos las líneas de la 11 la 15 pero de cualquier otro archivo. Vamos modificar el archivo que creamos.En el script, cuando colocamos \"$1\" se refiere al primer argumento/archivo en la línea de comandos, por ejemplo cuando colocamos en la línea de comandos:Lo que estamos diciéndole la consola es que reemplace dentro del script “$1” por el archivo octane.pdb. De esta forma nuestro script ahora lo podemos correr sobre cualquier archivo.Nuestro script por el momento funciona solo con las líneas de la 11 la 15. Supongamos que queremos modificar esto de tal forma que cuando vayamos ejecutar el script le indiquemos las líneas que queremos extraer. Así como usamos $1 para indicarle que era la primera variable en la línea de comandos, podemos usar las variables $2 y $3 para indicarle la segunda y tercera variable.Entonces podemos ejecutar el script como sigue:Y podemos cambiar las líneas mostrar, por ejemplo:Lo único que falta en el script, es describir que hace, de esta forma cualquier otra persona (o nosotros más adelante), cuando queramos abrir el script podamos recordar y entender que argumentos pide y cual es su uso.Ahora, supongamos que queremos ordenar los archivos .pdb por cantidad de líneas. Sin un script eso lo hacemos así:Si queremos poner esto en un script pero queremos correrlo sobre varios tipos de archivos, digamos los .pdb y los .dat, podemos colocar en nuestro script *.pdb, y si usamos como en los ejemplos anteriores \"$1\" o \"$2, eso limitaría la cantidad de archivos que podemos pasarle después en la consola. Una forma de depender de eso es con la variable $@, esto indica que pueden ser cualquier cantidad de argumentos en la línea de comandos.Ejercicio: El archivo animals.csv ya vimos que es un archivo separado por comas que indica las especies y la cantidad de cada uno. Crea un script que se pueda aplicar cualquier cantidad de archivos con ese formato y que te diga las especies únicas de cada archivo.\nCrea 3 archivos similares al animals.csv (copia y modifica) y prueba tu script.Ejercicio: Corre el siguiente comando:¿Qué contiene ese archivo? ¿Observa la última línea del archivo? ¿Porqué guarda esa línea?Ejercicio: En la carpeta alkanes supongamos que tenemos un script.sh que contiene lo siguiente:Dentro del directorio alkanes, corre lo siguiente:¿Qué esperas obtener?Ejercicio: Crea un script llamado longest.sh que reciba como argumentos un directorio y una extensión de archivos y que te devuelva el archivo en el directorio, que tenga esa extensión, con el mayor número de líneas.Ejercicio: Considera los archivos que están en la carpeta alkanes. Explica que hace cada uno de los siguientes scripts al correrlos como bash script1.sh *.pdb, bash script2.sh *.pdb y bash script3.sh *.pdb.Ejercicio: (Debugging) Supongamos que tienen el siguiente script -errors.sh en la carpeta north-pacific-gyre:Corre en la línea de comandos:muestra ninguna salida. Para ver porque, vamos correrlo de nuevo con la opción -x:¿Cuál es el output? ¿Cuál es la línea responsable del error?","code":"$ head -n 15 octane.pdb | tail -n 5$ cd alkanes\n$ nano middle.sh$ bash middle.sh$ nano middle.shhead -n 15 \"$1\" | tail -n 5$ bash middle.sh octane.pdb$ nano middle.shhead -n \"$2\" \"$1\" | tail -n \"$3\"$ bash middle.sh octane.pdb 15 5$ bash middle.sh octane.pdb 20 5$ nano middle.sh# Selecciona líneas intermedias de un archivo.\n# Uso: bash middle.sh nombre_archivo linea_final linea_inicial\nhead -n \"$2\" \"$1\" | tail -n \"$3\"$ wc -l *.pdb | sort -n $ nano sorted.sh# Ordena archivos por su longitud\n# Uso: bash sorted.sh uno_o_mas_archivos\nwc -l \"$@\" | sort -n$ bash sorted.sh *.pdb ../creatures/*.dat$ history | tail -n 5 > recientes.sh$ head -n $2 $1\n$ tail -n $3 $1$ bash script.sh '*.pdb' 1 1# Script 1\necho *.*# Script 2\nfor filename in $1 $2 $3\ndo\n  cat $filename\ndone# Script 3\necho $@.pdb# Calcular estadisticas para los archivos\nfor datafile in \"$@\"\ndo\n  echo $datafile\n  bash goostats.sh $datfile stats-$datafile\ndone$ bash do-errors.sh NENE*A.txt NENE*B.txt$ bash -x do-errors.sh NENE*A.txt NENE*B.txt"},{"path":"shell.html","id":"buscando-y-encontrando-cosas","chapter":"Sección 2 Shell","heading":"2.6 Buscando y encontrando cosas","text":"","code":""},{"path":"shell.html","id":"descarga-y-limpieza-de-bases-de-datos","chapter":"Sección 2 Shell","heading":"2.7 Descarga y limpieza de bases de datos","text":"","code":""},{"path":"git-y-github.html","id":"git-y-github","chapter":"Sección 3 Git y Github","heading":"Sección 3 Git y Github","text":"","code":""},{"path":"git-y-github.html","id":"repositorios","chapter":"Sección 3 Git y Github","heading":"3.1 Repositorios","text":"","code":""},{"path":"git-y-github.html","id":"flujo-de-trabajo-en-git","chapter":"Sección 3 Git y Github","heading":"3.2 Flujo de trabajo en Git","text":"","code":""},{"path":"git-y-github.html","id":"comparando-cambios","chapter":"Sección 3 Git y Github","heading":"3.3 Comparando cambios","text":"","code":""},{"path":"git-y-github.html","id":"crear-ramas","chapter":"Sección 3 Git y Github","heading":"3.4 Crear Ramas","text":"","code":""},{"path":"git-y-github.html","id":"actualizando-ramas","chapter":"Sección 3 Git y Github","heading":"3.5 Actualizando ramas","text":"","code":""},{"path":"git-y-github.html","id":"revertir-cambios","chapter":"Sección 3 Git y Github","heading":"3.6 Revertir cambios","text":"","code":""},{"path":"git-y-github.html","id":"resolver-conflictos","chapter":"Sección 3 Git y Github","heading":"3.7 Resolver conflictos","text":"","code":""},{"path":"python.html","id":"python","chapter":"Sección 4 Python","heading":"Sección 4 Python","text":"","code":""},{"path":"python.html","id":"tipos-de-datos","chapter":"Sección 4 Python","heading":"4.1 Tipos de datos","text":"","code":""},{"path":"python.html","id":"flujo-de-control","chapter":"Sección 4 Python","heading":"4.2 Flujo de control","text":"","code":""},{"path":"python.html","id":"visualización-de-datos","chapter":"Sección 4 Python","heading":"4.3 Visualización de datos","text":"","code":""},{"path":"python.html","id":"manipulación-de-bases-de-datos","chapter":"Sección 4 Python","heading":"4.4 Manipulación de bases de datos","text":"","code":""},{"path":"python.html","id":"análisis-exploratorio-de-bases-de-datos","chapter":"Sección 4 Python","heading":"4.5 Análisis exploratorio de bases de datos","text":"","code":""},{"path":"python.html","id":"funciones-y-scripts","chapter":"Sección 4 Python","heading":"4.6 Funciones y scripts","text":"","code":""},{"path":"python.html","id":"buenas-practicas","chapter":"Sección 4 Python","heading":"4.7 Buenas practicas","text":"","code":""},{"path":"python.html","id":"procesamiento-de-alto-rendimiento","chapter":"Sección 4 Python","heading":"4.8 Procesamiento de alto rendimiento","text":"","code":""},{"path":"python.html","id":"programación-en-paralelo","chapter":"Sección 4 Python","heading":"4.9 Programación en paralelo","text":"","code":""},{"path":"sql.html","id":"sql","chapter":"Sección 5 SQL","heading":"Sección 5 SQL","text":"","code":""},{"path":"sql.html","id":"bases-de-datos-y-manipulación","chapter":"Sección 5 SQL","heading":"5.1 Bases de datos y manipulación","text":"","code":""},{"path":"sql.html","id":"explorar-datos-categóricos-y-texto-no-estructurado","chapter":"Sección 5 SQL","heading":"5.2 Explorar datos categóricos y texto no estructurado","text":"","code":""},{"path":"sql.html","id":"comparación-con-los-otros-programas","chapter":"Sección 5 SQL","heading":"5.3 Comparación con los otros programas","text":"","code":""},{"path":"sql.html","id":"valores-faltantes","chapter":"Sección 5 SQL","heading":"5.4 Valores faltantes","text":"","code":""},{"path":"sql.html","id":"combinar-bases-de-datos","chapter":"Sección 5 SQL","heading":"5.5 Combinar bases de datos","text":"","code":""},{"path":"power-bi.html","id":"power-bi","chapter":"Sección 6 Power BI","heading":"Sección 6 Power BI","text":"","code":""},{"path":"power-bi.html","id":"introducción-a-power-bi","chapter":"Sección 6 Power BI","heading":"6.1 Introducción a Power BI","text":"","code":""},{"path":"power-bi.html","id":"transformando-y-visualizando-datos","chapter":"Sección 6 Power BI","heading":"6.2 Transformando y visualizando datos","text":"","code":""},{"path":"power-bi.html","id":"manipulación-de-bases-de-datos-1","chapter":"Sección 6 Power BI","heading":"6.3 Manipulación de bases de datos","text":"","code":""},{"path":"power-bi.html","id":"análisis-exploratorio-de-bases-de-datos-1","chapter":"Sección 6 Power BI","heading":"6.4 Análisis exploratorio de bases de datos","text":"","code":""},{"path":"power-bi.html","id":"variables-categóricas-y-continuas","chapter":"Sección 6 Power BI","heading":"6.5 Variables categóricas y continuas","text":"","code":""},{"path":"r.html","id":"r","chapter":"Sección 7 R","heading":"Sección 7 R","text":"","code":""},{"path":"r.html","id":"tipos-de-datos-1","chapter":"Sección 7 R","heading":"7.1 Tipos de datos","text":"","code":""},{"path":"r.html","id":"manipulación-de-bases-de-datos-2","chapter":"Sección 7 R","heading":"7.2 Manipulación de bases de datos","text":"","code":""},{"path":"r.html","id":"análisis-exploratorio-de-bases-de-datos-2","chapter":"Sección 7 R","heading":"7.3 Análisis exploratorio de bases de datos","text":"","code":""},{"path":"r.html","id":"reportes-con-rmarkdown","chapter":"Sección 7 R","heading":"7.4 Reportes con RMarkdown","text":"","code":""},{"path":"r.html","id":"páginas-web","chapter":"Sección 7 R","heading":"7.5 Páginas web","text":"","code":""}]
