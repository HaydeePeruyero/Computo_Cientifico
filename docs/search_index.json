[["python.html", "Sección 4 Python 4.1 Breve introducción a los lenguajes de programación. 4.2 Entornos interactivos 4.3 Palabras reservadas de Python. 4.4 Sintaxis de nombres en Python 4.5 Tipos de datos 4.6 Flujo de control 4.7 Numpy 4.8 Visualización de datos 4.9 Data frames con pandas 4.10 Manipulación de bases de datos 4.11 Análisis exploratorio de bases de datos 4.12 Funciones y scripts 4.13 Buenas practicas 4.14 Procesamiento de alto rendimiento 4.15 Programación en paralelo", " Sección 4 Python Python es un lenguaje de programación de alto nivel, interactivo e interpretado. Es de código abierto, multi-plataforma y se adecua a diversos paradigmas de programación como lo es la programación orientada a objetos. El intérprete de Python y su amplia gama de bibliotecas estándar están disponibles de forma gratuita para la mayoría de plataformas en el sitio web oficial de Python. Además, este sitio proporciona documentación adicional, programas y herramientas que complementan su ecosistema. Características de Python: Sintaxis muy clara y legible. Fuerte capacidad de introspección. Orientación a objetos intuitiva. Altamente modular, soporta paquetes jerárquicos. Enfocado en el uso de excepciones para el manejo de errores. Tipos de datos dinámicos de muy alto nivel. Extensa biblioteca estándar (STL) y módulos de terceros para prácticamente todas las tareas. Extensiones y módulos fácilmente escritos en C, C + + (o Java para Jython, o. NET para IronPython). Integrable dentro de las aplicaciones como una interfaz de scripting. Aplicaciones de Python: se ha utilizado para desarrollar: Aplicaciones de escritorio. Aplicaciones web. Análisis de datos. Administración de servidores. Seguridad y análisis de penetración. Cómputo en la nube. Cómputo científico. Análisis de lenguaje natural. Visión artificial. Animación, videojuegos e imágenes generadas por computadora. Aplicaciones móviles. 4.1 Breve introducción a los lenguajes de programación. Un lenguaje se define como un conjunto de secuencias de símbolos que posibilitan la creación y transmisión de mensajes entre un emisor y un receptor. Aunque la naturaleza exhibe ciertos tipos de lenguajes, los seres humanos han desarrollado una variedad de sistemas lingüísticos de gran complejidad. Los lenguajes se componen principalmente de dos aspectos: la gramática, que aborda la estructura del lenguaje, y la semántica, que se ocupa del significado del lenguaje. La gramática, a su vez, incluye: Morfología: relacionada con la construcción de las unidades lingüísticas (género, tiempos verbales, declinaciones). Sintaxis: referente a la manera en que se deben ordenar y estructurar las unidades lingüísticas en las expresiones. En el transcurso del siglo XX, figuras como Alan Turing y Alonzo Church sentaron los fundamentos del cálculo, la programación y sus respectivos lenguajes. Los lenguajes de programación contemporáneos, a diferencia de los lenguajes naturales, presentan una morfología estructurada y simplificada diseñada para ejecutar instrucciones precisas en los sistemas informáticos. Lenguajes de alto y bajo nivel: Los lenguajes de bajo nivel, como el lenguaje ensamblador, consisten en un conjunto elemental de instrucciones que son ejecutadas directamente por la unidad de procesamiento de un sistema informático. Estos lenguajes están estrechamente vinculados al tipo de procesador que los procesa y suelen ser difíciles de elaborar e interpretar para las personas. Por otro lado, los lenguajes de alto nivel son más comprensibles para los humanos y, en general, menos dependientes del hardware específico, aunque requieren ser traducidos a lenguaje de bajo nivel para su ejecución. Lenguajes compilados e interpretados: Los lenguajes de alto nivel se comunican con los sistemas informáticos de dos maneras distintas: A través de un compilador, que traduce el código del programa a lenguaje de bajo nivel, generando un “archivo binario” que puede ser ejecutado posteriormente. Mediante un intérprete, que ejecuta las instrucciones ingresadas de inmediato. Por lo general, los lenguajes compilados son más eficientes en términos de velocidad y consumo de recursos que los lenguajes interpretados, ya que el archivo resultante es código de bajo nivel. En contraste, los lenguajes interpretados requieren un proceso adicional a través de varios niveles de abstracción antes de que las instrucciones sean ejecutadas por el sistema. Python es un lenguaje interpretado de alto nivel. 4.2 Entornos interactivos Debido a que Python es un lenguaje interpretado, es posible utilizarlo mediante un entorno interactivo (shell) o mediante el uso de scripts. El shell interactivo de Python funciona a través de una terminal. Para sistemas basados en UNIX, como GNU/Linux, y Mac OS X, es requerido abrir una terminal y llamar al shell de la siguiente manera: python Dependiendo de la versión o la forma en que fue instalado, a veces se manda a llamar con la siguiente forma: python3 Para salir del entorno interactivo usamos exit() Para desplegar el texto Hola Mundo desde en entorno interactivo sólo es necesario teclear lo siguiente: print(&quot;Hola, Mundo.&quot;) ## Hola, Mundo. 4.3 Palabras reservadas de Python. Las palabras reservadas, también conocidas como keywords, son los nombres predeterminados que el intérprete de Python proporciona de forma inherente. No se recomienda emplear estas palabras para asignar nombres a otros objetos. Para acceder al listado completo de palabras reservadas, se puede consultar ingresando help(‘keywords’) desde la interfaz interactiva de Python. help(&quot;keywords&quot;) ## ## Here is a list of the Python keywords. Enter any keyword to get more help. ## ## False class from or ## None continue global pass ## True def if raise ## and del import return ## as elif in try ## assert else is while ## async except lambda with ## await finally nonlocal yield ## break for not 4.4 Sintaxis de nombres en Python En Python 3, la sintaxis para la elaboración de nombres sigue ciertas reglas y convenciones que son importantes para escribir un código claro y legible. Aquí hay algunas pautas clave: Caracteres permitidos: Los nombres pueden incluir letras minúsculas (a-z), letras mayúsculas (A-Z), dígitos (0-9) y el guion bajo (_). No pueden comenzar con un número. Convenciones de estilo: Se recomienda seguir las convenciones de estilo de Python, que generalmente sugieren el uso de minúsculas para los nombres de variables y funciones, y mayúsculas para constantes. Para nombres compuestos, se recomienda separar las palabras con guiones bajos (snake_case). Palabras reservadas: No se pueden utilizar palabras reservadas de Python como nombres de variables, ya que estas palabras tienen significados específicos en el lenguaje y están reservadas para su uso en la sintaxis de Python. Significado claro: Es importante elegir nombres que proporcionen un significado claro y descriptivo sobre el propósito de la variable, función o clase que están representando. Esto ayuda a que el código sea más legible y comprensible para otros programadores. Evitar nombres genéricos: Trate de evitar nombres genéricos como “a”, “b”, “x”, etc. Utilice nombres que reflejen el propósito y la función de la variable o función. 4.5 Tipos de datos En Python, los tipos de datos son la base de cualquier programa. Python es un lenguaje de programación dinámico, por lo que no es necesario declarar explícitamente el tipo de datos cuando se crea una variable. A continuación, exploraremos los tipos de datos básicos en Python. Tipo de dato Descripción Ejemplo Colección Indexable Mutable int Números enteros 5, -10, 100 No No No float Números de punto flotante 3.14, -0.001, 2.0 No No No str Cadena de caracteres ‘Hola’, “Mundo” No Sí No bool Booleano (Verdadero o Falso) True, False No Sí No list Lista ordenada de elementos [1, 2, 3], [‘a’, ‘b’, ‘c’] Sí Sí Sí tuple Secuencia inmutable de elementos (1, 2, 3), (‘a’, ‘b’, ‘c’) Sí Sí No dict Colección de pares clave-valor {‘nombre’: ‘Juan’, ‘edad’: 30} Sí No Sí set Colección no ordenada de elementos únicos {1, 2, 3}, {‘a’, ‘b’, ‘c’} Sí No Sí Las colecciones son estructuras que almacenan una serie de elementos. Cada uno de estos elementos se puede considerar como una entidad independiente dentro de la colección. Los tipos indexables permiten acceder a cada elemento dentro de la colección mediante un identificador único, que puede ser un número entero (índice) o una clave, dependiendo del tipo de colección. Los tipos mutables tienen la característica de permitir la modificación de su contenido. Esto incluye la capacidad de agregar, eliminar o modificar elementos existentes en la colección. 4.5.1 Números En Python, hay tres tipos principales de números: enteros (int), números de punto flotante (float) y números complejos (complex). Veamos ejemplos de cada uno: # Entero numero_entero = 10 print(numero_entero) ## 10 # Punto flotante numero_flotante = 3.14 print(numero_flotante) ## 3.14 # Complejo numero_complejo = 2 + 3j print(numero_complejo) ## (2+3j) La precisión de los números flotantes debe ser considerada cuidadosamente, ya que está influenciada significativamente por la capacidad del equipo de cómputo. En ciertas ocasiones, las operaciones con números de tipo float pueden arrojar aproximaciones en lugar de resultados exactos. Es importante tener en cuenta estas limitaciones al trabajar con números flotantes. 2 / 3 ## 0.6666666666666666 Python permite realizar operaciones básicas con los tipos de datos mencionados anteriormente. A continuación, se muestran algunos ejemplos: # Operaciones numéricas resultado = 10 + 5 diferencia = 10 - 5 producto = 10 * 5 cociente = 10 / 5 modulo = 10 % 3 potencia = 10 ** 2 4.5.2 Cadenas de Caracteres Las cadenas de caracteres (str) se utilizan para representar texto en Python. Se pueden definir utilizando comillas simples (’) o dobles (“): cadena_simple = &#39;Hola, mundo!&#39; print(cadena_simple) ## Hola, mundo! cadena_doble = &quot;¡Hola, Python!&quot; print(cadena_doble) ## ¡Hola, Python! En Python podemos concatenar cadenas de caracteres al sumarlas: # Concatenación de cadenas saludo = &quot;Hola&quot; + &quot; &quot; + &quot;Mundo&quot; print(saludo) ## Hola Mundo La indexación en Python te permite acceder a elementos individuales dentro de una secuencia, como una cadena de caracteres (string) o una lista. Los índices se utilizan para identificar la posición de un elemento en la secuencia. Índices positivos: Comienzan desde 0 y avanzan hacia la derecha. Índices negativos: Comienzan desde -1 y avanzan hacia la izquierda. a = &quot;hola&quot; print(a[0]) # Salida: &#39;h&#39; ## h print(a[1]) # Salida: &#39;o&#39; ## o print(a[-1]) # Salida: &#39;a&#39; ## a El rebanado (slicing) te permite extraer subconjuntos de elementos de una secuencia, como una cadena de caracteres o una lista. La sintaxis general para el rebanado es inicio:fin:paso, donde: inicio: Índice desde el cual comienza la rebanada. fin: Índice hasta el cual se incluyen elementos en la rebanada, pero no incluyendo el elemento en este índice. paso: Tamaño del paso o incremento entre los elementos seleccionados. a = &quot;hola, mundooo!&quot; print(a[3:6]) ## a, print(a[2:10:2]) ## l,mn print(a[::3]) ## hamdo Las cadenas de caracteres son inmutables en Python, lo que significa que no se pueden modificar directamente. Sin embargo, puedes crear nuevas cadenas basadas en las originales utilizando métodos como replace(). a = &quot;hola, clase!&quot; nueva_cadena = a.replace(&#39;l&#39;, &#39;z&#39;, 1) print(nueva_cadena) ## hoza, clase! a = &quot;hola, clase!&quot; nueva_cadena = a.replace(&#39;l&#39;, &#39;z&#39;) # Reemplaza todas las &#39;l&#39; con &#39;z&#39; print(nueva_cadena) ## hoza, czase! Las cadenas de caracteres en Python tienen una variedad de métodos útiles que puedes utilizar para manipular y trabajar con ellas. Puedes acceder a estos métodos utilizando la notación de punto después de una cadena de caracteres seguida por el método que deseas utilizar. El formateo de cadenas en Python te permite crear cadenas complejas combinando texto y valores de variables de una manera legible y eficiente. Hay varias formas de formatear cadenas en Python, incluidas las expresiones de formato, el método format(), y el formateo de cadenas con el operador %. El operador % se utiliza para insertar valores en una cadena utilizando un formato específico. Especificadores de Formato: %d: Entero decimal. %f: Número de punto flotante. %s: Cadena de caracteres. # Ejemplo de formateo de cadena con el operador % cadena = &#39;Un entero: %i; un flotante: %f; otra cadena: %s&#39; % (1, 0.1, &#39;cadena&#39;) print(cadena) ## Un entero: 1; un flotante: 0.100000; otra cadena: cadena # Formateo de nombres de archivos i = 102 nombre_archivo = &#39;procesamiento_del_dataset_%d.txt&#39; % i print(nombre_archivo) ## procesamiento_del_dataset_102.txt En el primer ejemplo, se insertan un entero, un flotante y una cadena en la cadena de formato utilizando el operador %. En el segundo ejemplo, se utiliza el operador % para insertar un entero en el nombre del archivo. Cuando se insertan múltiples valores, estos deben estar dentro de una tupla ( ) después del operador %. Si solo se inserta un valor, no es necesario el uso de tuplas después del operador %. El operador % es útil pero está siendo reemplazado gradualmente por el método format(). El método format() es una técnica más moderna y flexible para formatear cadenas en comparación con el uso del operador %. Aunque el operador % todavía es válido y funcional, se recomienda utilizar el método format() debido a su mayor versatilidad y legibilidad. El método format() permite insertar valores en una cadena de forma más explícita y flexible. Utiliza llaves {} como marcadores de posición en la cadena, y luego proporciona los valores que se insertarán en esos marcadores de posición. Por ejemplo: # Ejemplo básico cadena = &quot;Hola, {}! Hoy es {}.&quot; mensaje = cadena.format(&quot;Juan&quot;, &quot;miércoles&quot;) print(mensaje) ## Hola, Juan! Hoy es miércoles. # Especificando el orden de los argumentos cadena = &quot;Hola, {1}! Hoy es {0}.&quot; mensaje = cadena.format(&quot;lunes&quot;, &quot;María&quot;) print(mensaje) ## Hola, María! Hoy es lunes. # Especificando nombres de argumentos cadena = &quot;Hola, {nombre}! Hoy es {dia}.&quot; mensaje = cadena.format(nombre=&quot;Pedro&quot;, dia=&quot;jueves&quot;) print(mensaje) ## Hola, Pedro! Hoy es jueves. Algunas ventajas de format() sobre %: Legibilidad mejorada: El método format() ofrece una sintaxis más clara y legible en comparación con el operador %. Mayor flexibilidad: format() permite especificar el orden de los argumentos y asignar nombres a los argumentos, lo que lo hace más flexible y fácil de mantener en comparación con el operador %. Compatible con objetos de diferentes tipos: format() es compatible con una amplia gama de tipos de datos y objetos, lo que lo hace más versátil en comparación con el operador %. 4.5.3 Listas Una lista (list) en Python es una secuencia ordenada de elementos que pueden ser de diferentes tipos. Se definen utilizando corchetes []: mi_lista = [1, 2, 3, &#39;cuatro&#39;, 5.0] print(mi_lista) ## [1, 2, 3, &#39;cuatro&#39;, 5.0] Para acceder a los elementos de una lista, podemos usar su índice. Los índices en Python comienzan desde 0 para el primer elemento y van incrementando de uno en uno. mi_lista = [1, 2, 3, &#39;cuatro&#39;, 5.0] primer_elemento = mi_lista[0] print(primer_elemento) ## 1 print(mi_lista[0]) # Imprime el primer elemento: 1 ## 1 print(mi_lista[3]) # Imprime &#39;cuatro&#39; ## cuatro También se puede acceder a los elementos de la lista utilizando índices negativos, los cuales cuentan desde el final de la lista hacia el principio. print(mi_lista[-1]) # Imprime el último elemento: 5.0 ## 5.0 print(mi_lista[-2]) # Imprime &#39;cuatro&#39; ## cuatro Puedes añadir elementos a una lista utilizando el método append() para agregar un elemento al final de la lista. mi_lista.append(6) print(mi_lista) ## [1, 2, 3, &#39;cuatro&#39;, 5.0, 6] También puedes extender una lista añadiendo todos los elementos de otra lista utilizando el método extend(). mi_lista.extend([7, 8, 9]) print(mi_lista) ## [1, 2, 3, &#39;cuatro&#39;, 5.0, 6, 7, 8, 9] Puedes eliminar elementos de una lista utilizando la palabra clave del seguida del índice del elemento que deseas eliminar. del mi_lista[3] # Elimina el elemento &#39;cuatro&#39; print(mi_lista) ## [1, 2, 3, 5.0, 6, 7, 8, 9] También puedes utilizar el método remove() para eliminar un elemento específico por su valor. mi_lista.remove(3) # Elimina el elemento 3 print(mi_lista) ## [1, 2, 5.0, 6, 7, 8, 9] Puedes unir dos listas utilizando el operador + o el método extend(). lista1 = [1, 2, 3] lista2 = [4, 5, 6] nueva_lista = lista1 + lista2 print(nueva_lista) ## [1, 2, 3, 4, 5, 6] lista1.extend(lista2) print(lista1) ## [1, 2, 3, 4, 5, 6] Otra forma de operar listas es la siguiente. La repetición de listas implica crear una nueva lista duplicando los elementos de una lista existente un número determinado de veces. Puedes lograr esto utilizando el operador de multiplicación. Por ejemplo: colores = [&#39;rojo&#39;, &#39;verde&#39;, &#39;azul&#39;] colores_repetidos = colores * 3 print(colores_repetidos) ## [&#39;rojo&#39;, &#39;verde&#39;, &#39;azul&#39;, &#39;rojo&#39;, &#39;verde&#39;, &#39;azul&#39;, &#39;rojo&#39;, &#39;verde&#39;, &#39;azul&#39;] El método sort() ordena los elementos de la lista en orden ascendente de forma predeterminada. Sin embargo, también acepta argumentos opcionales que te permiten personalizar el ordenamiento según tus necesidades. Por ejemplo, para ordenarlos ascendente: # Definir una lista desordenada de colores colores = [&#39;rojo&#39;, &#39;verde&#39;, &#39;azul&#39;, &#39;amarillo&#39;, &#39;naranja&#39;, &#39;morado&#39;] # Ordenar la lista de colores en orden ascendente colores.sort() # Imprimir la lista ordenada print(colores) ## [&#39;amarillo&#39;, &#39;azul&#39;, &#39;morado&#39;, &#39;naranja&#39;, &#39;rojo&#39;, &#39;verde&#39;] Para ordenarlas de forma descendente: # Definir una lista desordenada de colores colores = [&#39;rojo&#39;, &#39;verde&#39;, &#39;azul&#39;, &#39;amarillo&#39;, &#39;naranja&#39;, &#39;morado&#39;] # Ordenar la lista de colores en orden descendente colores.sort(reverse=True) # Imprimir la lista ordenada print(colores) ## [&#39;verde&#39;, &#39;rojo&#39;, &#39;naranja&#39;, &#39;morado&#39;, &#39;azul&#39;, &#39;amarillo&#39;] Algunas notas a considerar: El método sort() modifica la lista original y no devuelve ningún valor. Si los elementos de la lista son de tipos diferentes, la función sort() generará un error de tipo. Si deseas ordenar una lista sin modificar la original, puedes usar la función sorted(), que devuelve una nueva lista ordenada sin modificar la lista original. Otra forma de acceder a los datos de las listas en Python es usando el método de “rebanada” (slice): lista[inicio:fin]. Esta rebanada incluye los elementos cuyos índices están en el rango desde inicio hasta fin - 1: inicio: Es el índice desde el cual comenzamos a incluir elementos en la rebanada. fin: Es el índice hasta el cual incluimos elementos en la rebanada, pero no incluyendo el elemento en este índice. Supongamos que tenemos una lista llamada colores: colores = [&#39;rojo&#39;, &#39;verde&#39;, &#39;azul&#39;, &#39;amarillo&#39;, &#39;naranja&#39;, &#39;morado&#39;] Por ejemplo, si queremos obtener una rebanada de colores desde el índice 1 hasta el índice 4, usaríamos la notación colores[1:4] y vamos a obtener una rebanada que incluye elementos desde el índice 1 (inclusive) hasta el índice 4 (no inclusive). colores[1:4] ## [&#39;verde&#39;, &#39;azul&#39;, &#39;amarillo&#39;] Si ejecutamos colores[2:5], obtendremos una rebanada que incluye elementos desde el índice 2 (inclusive) hasta el índice 5 (no inclusive). La rebanada contendrá los elementos 'azul', 'amarillo' y 'naranja'. print(colores[2:5]) ## [&#39;azul&#39;, &#39;amarillo&#39;, &#39;naranja&#39;] La longitud de la rebanada colores[inicio:fin] es fin - inicio. Es decir, el número de elementos en la rebanada es igual a la diferencia entre el índice de parada y el índice de inicio. Por ejemplo, colores[1:4] contiene los elementos desde el índice 1 hasta el índice 3 (no incluido), lo que hace que tenga una longitud de 4 - 1 = 3. Esta es una manera flexible y poderosa de acceder a subconjuntos de elementos en una lista en Python. Otra sintaxis de “rebanadas” en Python con la notación colores[inicio:fin:salto] se refiere a la técnica para seleccionar un subconjunto de elementos de una lista (colors) utilizando tres parámetros: inicio: Indica el índice desde el cual comenzamos a incluir elementos en la rebanada. fin: Indica el índice hasta el cual incluimos elementos en la rebanada, sin incluir el elemento en este índice. salto: Indica el tamaño del paso o incremento entre los elementos seleccionados. Es decir, cuántos elementos saltamos en cada paso. Si ejecutamos colores[::2], obtenemos una rebanada que incluye todos los elementos de la lista colores, pero seleccionando cada segundo elemento. Es como si empezáramos desde el principio de la lista, terminando al final y seleccionando cada segundo elemento. print(colores[::2]) ## [&#39;rojo&#39;, &#39;azul&#39;, &#39;naranja&#39;] Si ejecutamos colores[1:5:2], obtenemos una rebanada que incluye elementos desde el índice 1 (inclusive) hasta el índice 5 (no inclusive), seleccionando cada segundo elemento en ese rango. print(colores[1:5:2]) ## [&#39;verde&#39;, &#39;amarillo&#39;] También es posible usar un valor de salto negativo, lo que significa que los elementos se seleccionan en orden inverso. Por ejemplo, colores[::-1] devuelve una rebanada que incluye todos los elementos de colores, pero en orden inverso. print(colores[::-1]) ## [&#39;morado&#39;, &#39;naranja&#39;, &#39;amarillo&#39;, &#39;azul&#39;, &#39;verde&#39;, &#39;rojo&#39;] Ejercicios: Dada una lista de números, intercambia cada par de elementos adyacentes. Por ejemplo, si la lista es [1, 2, 3, 4, 5], el resultado sería [2, 1, 4, 3, 5]. Dada una lista de letras, invierte el orden de los elementos en grupos de tres. Por ejemplo, si la lista es [‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’, ‘g’, ‘h’, ‘i’], el resultado sería [‘c’, ‘b’, ‘a’, ‘f’, ‘e’, ‘d’, ‘i’, ‘h’, ‘g’]. Soluciones: Link Cuando necesitas realizar una copia de una lista en Python, es importante entender que simplemente hacer colores2 = colores no crea una copia real de la lista. Ambas variables, colores2 y colores, apuntarán a la misma lista en la memoria. Esto significa que cualquier modificación realizada en una de las variables afectará a la otra. Para crear una copia real de la lista, puedes usar el método list() o la técnica de rebanada. Usando el método list(): colores2 = list(colores) # Crear una copia de colores en una nueva lista colores2 Usando rebanadas: rcolores2 = colores[:] # Crear una copia de colores en una nueva lista rcolores2 En Python, puedes revertir el orden de los elementos en una lista utilizando el método reverse(). Uso del método reverse(): rcolores2.reverse() # Revertir el orden de los elementos en la lista rcolores2 Esto modificará la lista original en su lugar y no devolverá ninguna nueva lista. # Definir una lista de colores colores = [&#39;rojo&#39;, &#39;verde&#39;, &#39;azul&#39;, &#39;amarillo&#39;, &#39;naranja&#39;, &#39;morado&#39;] # Crear una copia de colors en una nueva lista rcolors2 rcolores2 = list(colores) # Revertir el orden de los elementos en la lista rcolors2 rcolores2.reverse() # Imprimir la lista original y la lista revertida print(&quot;Lista original:&quot;, colores) ## Lista original: [&#39;rojo&#39;, &#39;verde&#39;, &#39;azul&#39;, &#39;amarillo&#39;, &#39;naranja&#39;, &#39;morado&#39;] print(&quot;Lista revertida:&quot;, rcolores2) ## Lista revertida: [&#39;morado&#39;, &#39;naranja&#39;, &#39;amarillo&#39;, &#39;azul&#39;, &#39;verde&#39;, &#39;rojo&#39;] 4.5.4 Tuplas Las tuplas (tuple) son secuencias ordenadas similares a las listas, pero son inmutables, es decir, no se pueden modificar después de su creación. Se definen utilizando paréntesis (): mi_tupla = (1, 2, 3, &#39;cuatro&#39;, 5.0) print(mi_tupla) ## (1, 2, 3, &#39;cuatro&#39;, 5.0) Para acceder a los elementos de una tupla, podemos utilizar su índice, al igual que en las listas. ultimo_elemento = mi_tupla[-1] print(ultimo_elemento) ## 5.0 print(mi_tupla[0]) # Imprime el primer elemento: 1 ## 1 print(mi_tupla[3]) # Imprime &#39;cuatro&#39; ## cuatro También se puede acceder a los elementos de la tupla utilizando índices negativos, que cuentan desde el final de la tupla hacia el principio. print(mi_tupla[-1]) # Imprime el último elemento: 5.0 ## 5.0 print(mi_tupla[-2]) # Imprime &#39;cuatro&#39; ## cuatro Dado que las tuplas son inmutables, no se pueden borrar elementos individualmente ni modificar la tupla después de su creación. Aunque las tuplas son inmutables, todavía tienen algunas características útiles en Python: Empaquetado y desempaquetado de tuplas: Puedes empaquetar múltiples valores en una sola tupla y desempaquetarlos en variables individuales. tupla = 1, 2, 3 # Empaquetado de valores a, b, c = tupla # Desempaquetado en variables individuales print(a, b, c) # Imprime 1 2 3 ## 1 2 3 El empaquetado y desempaquetado de tuplas son conceptos importantes en Python que permiten trabajar con múltiples valores de manera eficiente. El empaquetado de tuplas es el proceso de agrupar múltiples valores en una sola tupla. Esto se hace simplemente colocando los valores separados por comas, sin necesidad de utilizar paréntesis, por ejemplo: tupla_empaquetada = 1, 2, 3 Aquí, hemos empaquetado los valores 1, 2 y 3 en una sola tupla llamada tupla_empaquetada. El desempaquetado de tuplas es el proceso inverso al empaquetado. Permite extraer los valores individuales de una tupla y asignarlos a variables individuales. Esto se hace asignando la tupla a la derecha del signo de igualdad y las variables a la izquierda, por ejemplo: a, b, c = tupla_empaquetada Aquí, estamos desempaquetando la tupla tupla_empaquetada y asignando sus valores a las variables a, b y c respectivamente. Algunas de las ventajas del empaquetado y desempaquetado de tuplas son las siguientes: Sintaxis concisa: El empaquetado y desempaquetado de tuplas permite escribir código de manera más concisa y legible. Asignación múltiple: Permite asignar valores a múltiples variables en una sola línea de código. Los usos más comunes que tienen son los siguientes: Intercambio de valores: Se pueden intercambiar los valores de dos variables sin necesidad de una variable temporal utilizando el desempaquetado de tuplas. a, b = b, a Retorno múltiple de funciones: Las funciones pueden devolver múltiples valores empaquetados en una tupla, y luego estos valores pueden ser desempaquetados cuando se llama a la función. def obtener_coordenadas(): return 10, 20 x, y = obtener_coordenadas() print(&quot;Coordenadas:&quot;, x, y) ## Coordenadas: 10 20 El empaquetado y desempaquetado de tuplas son herramientas poderosas que permiten trabajar con múltiples valores de manera eficiente en Python. Tuplas como claves de diccionario: Dado que las tuplas son inmutables, pueden ser utilizadas como claves en un diccionario de Python. diccionario = {(1, 2): &#39;valor&#39;, (3, 4): &#39;otro valor&#39;} print(diccionario[(1, 2)]) # Imprime &#39;valor&#39; ## valor Aunque las tuplas son más simples que las listas, su inmutabilidad las hace útiles en situaciones donde no deseas que los datos cambien después de su definición. 4.5.5 Conjuntos Los conjuntos (set) son colecciones desordenadas de elementos únicos. Se definen utilizando llaves {}: mi_conjunto = {1, 2, 3, 4, 5} print(mi_conjunto) ## {1, 2, 3, 4, 5} Los conjuntos en Python son mutables, lo que significa que puedes agregar y eliminar elementos, pero no puedes modificar los elementos existentes directamente. Para agregar elementos a un conjunto, puedes utilizar el método add(). mi_conjunto.add(6) print(mi_conjunto) ## {1, 2, 3, 4, 5, 6} Para eliminar un elemento de un conjunto, puedes usar el método remove() o discard(). La diferencia entre estos dos métodos radica en cómo manejan la eliminación de un elemento que no está presente en el conjunto. remove() generará un error, mientras que discard() no. mi_conjunto.remove(3) print(mi_conjunto) ## {1, 2, 4, 5, 6} mi_conjunto.discard(5) print(mi_conjunto) ## {1, 2, 4, 6} Los conjuntos en Python admiten operaciones comunes de teoría de conjuntos como unión, intersección y diferencia. Unión: Combina todos los elementos únicos de dos conjuntos. conjunto1 = {1, 2, 3} conjunto2 = {3, 4, 5} union = conjunto1.union(conjunto2) print(union) ## {1, 2, 3, 4, 5} Intersección: Devuelve un conjunto que contiene los elementos que son comunes a ambos conjuntos. interseccion = conjunto1.intersection(conjunto2) print(interseccion) ## {3} Diferencia: Devuelve un conjunto que contiene los elementos que están en el primer conjunto pero no en el segundo. diferencia = conjunto1.difference(conjunto2) print(diferencia) ## {1, 2} Los conjuntos son útiles cuando necesitas almacenar una colección de elementos únicos y realizar operaciones de conjuntos eficientes como la eliminación de duplicados y la comparación de colecciones. En resumen, los conjuntos en Python proporcionan una manera eficiente de trabajar con colecciones de elementos únicos y son útiles para una variedad de tareas, como la eliminación de duplicadosy la realización de operaciones de conjuntos. 4.5.6 Diccionarios Los diccionarios (dict) son colecciones de pares clave-valor. Cada elemento del diccionario tiene una clave y un valor asociado. Se definen utilizando llaves {} y separando las claves y los valores con :: mi_diccionario = {&#39;nombre&#39;: &#39;Robeto&#39;, &#39;edad&#39;: 20, &#39;ciudad&#39;: &#39;Morelia&#39;} print(mi_diccionario) ## {&#39;nombre&#39;: &#39;Robeto&#39;, &#39;edad&#39;: 20, &#39;ciudad&#39;: &#39;Morelia&#39;} Los diccionarios en Python son mutables, lo que significa que puedes agregar, modificar y eliminar elementos según sea necesario. Puedes acceder a los valores del diccionario utilizando sus claves. print(mi_diccionario[&#39;nombre&#39;]) # Imprime &#39;Roberto&#39; ## Robeto print(mi_diccionario[&#39;edad&#39;]) # Imprime 20 ## 20 Si intentas acceder a una clave que no existe en el diccionario, Python generará un error KeyError. Puedes agregar un nuevo par clave-valor al diccionario simplemente asignando un valor a una nueva clave. mi_diccionario[&#39;email&#39;] = &#39;roberto@example.com&#39; print(mi_diccionario) ## {&#39;nombre&#39;: &#39;Robeto&#39;, &#39;edad&#39;: 20, &#39;ciudad&#39;: &#39;Morelia&#39;, &#39;email&#39;: &#39;roberto@example.com&#39;} Puedes modificar el valor asociado a una clave existente del diccionario. mi_diccionario[&#39;edad&#39;] = 21 print(mi_diccionario) ## {&#39;nombre&#39;: &#39;Robeto&#39;, &#39;edad&#39;: 21, &#39;ciudad&#39;: &#39;Morelia&#39;, &#39;email&#39;: &#39;roberto@example.com&#39;} Puedes eliminar un elemento del diccionario utilizando la palabra clave del. del mi_diccionario[&#39;ciudad&#39;] print(mi_diccionario) ## {&#39;nombre&#39;: &#39;Robeto&#39;, &#39;edad&#39;: 21, &#39;email&#39;: &#39;roberto@example.com&#39;} También puedes utilizar el método pop() para eliminar un elemento y devolver su valor. valor_eliminado = mi_diccionario.pop(&#39;edad&#39;) print(valor_eliminado) # Imprime 21 ## 21 print(mi_diccionario) ## {&#39;nombre&#39;: &#39;Robeto&#39;, &#39;email&#39;: &#39;roberto@example.com&#39;} Algunos conceptos clave de los diccionarios son los siguientes: keys(), values(), items(): Estos métodos devuelven vistas de las claves, valores y pares clave-valor del diccionario, respectivamente. Ejemplo de keys(): mi_diccionario = {&#39;nombre&#39;: &#39;Juan&#39;, &#39;edad&#39;: 30, &#39;ciudad&#39;: &#39;Madrid&#39;} claves = mi_diccionario.keys() print(claves) ## dict_keys([&#39;nombre&#39;, &#39;edad&#39;, &#39;ciudad&#39;]) # Iterar sobre las claves for clave in claves: print(clave) ## nombre ## edad ## ciudad Ejemplo de values(): mi_diccionario = {&#39;nombre&#39;: &#39;Juan&#39;, &#39;edad&#39;: 30, &#39;ciudad&#39;: &#39;Madrid&#39;} valores = mi_diccionario.values() print(valores) ## dict_values([&#39;Juan&#39;, 30, &#39;Madrid&#39;]) # Iterar sobre los valores for valor in valores: print(valor) ## Juan ## 30 ## Madrid Ejemplo de items(): mi_diccionario = {&#39;nombre&#39;: &#39;Juan&#39;, &#39;edad&#39;: 30, &#39;ciudad&#39;: &#39;Madrid&#39;} items = mi_diccionario.items() print(items) ## dict_items([(&#39;nombre&#39;, &#39;Juan&#39;), (&#39;edad&#39;, 30), (&#39;ciudad&#39;, &#39;Madrid&#39;)]) # Iterar sobre los pares clave-valor for clave, valor in items: print(clave, valor) ## nombre Juan ## edad 30 ## ciudad Madrid update(): Este método agrega los elementos de un diccionario a otro diccionario existente. diccionario1 = {&#39;a&#39;: 1, &#39;b&#39;: 2} diccionario2 = {&#39;b&#39;: 3, &#39;c&#39;: 4} diccionario1.update(diccionario2) print(diccionario1) # Salida: {&#39;a&#39;: 1, &#39;b&#39;: 3, &#39;c&#39;: 4} ## {&#39;a&#39;: 1, &#39;b&#39;: 3, &#39;c&#39;: 4} clear(): Este método elimina todos los elementos del diccionario. mi_diccionario = {&#39;nombre&#39;: &#39;Juan&#39;, &#39;edad&#39;: 30, &#39;ciudad&#39;: &#39;Madrid&#39;} mi_diccionario.clear() print(mi_diccionario) # Salida: {} ## {} Estos métodos son muy útiles para trabajar con diccionarios en Python y permiten manipular fácilmente las claves, valores y pares clave-valor, así como agregar, eliminar y actualizar elementos en los diccionarios de manera eficiente. Supongamos que queremos agregar nuevas entradas a nuestro diccionario, para eso usamos el método append. mi_diccionario = { &#39;nombre&#39;: [&#39;Roberta&#39;, &#39;María&#39;, &#39;Pedro&#39;], &#39;edad&#39;: [30, 25, 35], &#39;ciudad&#39;: [&#39;Madrid&#39;, &#39;Barcelona&#39;, &#39;Sevilla&#39;] } mi_diccionario[&#39;nombre&#39;].append(&#39;Luis&#39;) O podríamos definir las variables a agregar y usar el método append. mi_diccionario = { &#39;nombre&#39;: [&#39;Roberta&#39;, &#39;María&#39;, &#39;Pedro&#39;], &#39;edad&#39;: [30, 25, 35], &#39;ciudad&#39;: [&#39;Madrid&#39;, &#39;Barcelona&#39;, &#39;Sevilla&#39;] } # Agregar un nuevo nombre, edad y ciudad nuevo_nombre = &#39;Luis&#39; nueva_edad = 40 nueva_ciudad = &#39;Valencia&#39; mi_diccionario[&#39;nombre&#39;].append(nuevo_nombre) mi_diccionario[&#39;edad&#39;].append(nueva_edad) mi_diccionario[&#39;ciudad&#39;].append(nueva_ciudad) # Imprimir el diccionario actualizado print(mi_diccionario) ## {&#39;nombre&#39;: [&#39;Roberta&#39;, &#39;María&#39;, &#39;Pedro&#39;, &#39;Luis&#39;], &#39;edad&#39;: [30, 25, 35, 40], &#39;ciudad&#39;: [&#39;Madrid&#39;, &#39;Barcelona&#39;, &#39;Sevilla&#39;, &#39;Valencia&#39;]} Una forma de obtener los valores de edad y ciudad para cada nombre es la siguiente. mi_diccionario = { &#39;nombre&#39;: [&#39;Roberta&#39;, &#39;María&#39;, &#39;Pedro&#39;], &#39;edad&#39;: [30, 25, 35], &#39;ciudad&#39;: [&#39;Madrid&#39;, &#39;Barcelona&#39;, &#39;Sevilla&#39;] } # Recuperar listas de nombres y edades nombres = mi_diccionario[&#39;nombre&#39;] edades = mi_diccionario[&#39;edad&#39;] # Buscar la posición de María y Pedro en la lista de nombres pos_maria = nombres.index(&#39;María&#39;) pos_pedro = nombres.index(&#39;Pedro&#39;) # Obtener las edades de María y Pedro usando las posiciones encontradas edad_maria = edades[pos_maria] edad_pedro = edades[pos_pedro] # Imprimir las edades de María y Pedro print(&quot;Edad de María:&quot;, edad_maria) ## Edad de María: 25 print(&quot;Edad de Pedro:&quot;, edad_pedro) ## Edad de Pedro: 35 De una forma más directa, podemos obtener los valores como sigue: mi_diccionario = { &#39;nombre&#39;: [&#39;Juan&#39;, &#39;María&#39;, &#39;Pedro&#39;], &#39;edad&#39;: [30, 25, 35], &#39;ciudad&#39;: [&#39;Madrid&#39;, &#39;Barcelona&#39;, &#39;Sevilla&#39;] } # Obtener las edades de María y Pedro directamente del diccionario edad_maria = mi_diccionario[&#39;edad&#39;][mi_diccionario[&#39;nombre&#39;].index(&#39;María&#39;)] edad_pedro = mi_diccionario[&#39;edad&#39;][mi_diccionario[&#39;nombre&#39;].index(&#39;Pedro&#39;)] # Imprimir las edades de María y Pedro print(&quot;Edad de María:&quot;, edad_maria) ## Edad de María: 25 print(&quot;Edad de Pedro:&quot;, edad_pedro) ## Edad de Pedro: 35 Los diccionarios en Python son estructuras de datos muy versátiles y se utilizan ampliamente para mapear claves a valores y para almacenar datos de manera eficiente. Son útiles para muchas tareas, como el almacenamiento de configuraciones, el modelado de datos y la manipulación de datos estructurados. 4.5.7 Ejercicios Crea una lista que contenga los nombres de tres amigos tuyos. Crea un diccionario que represente la información de un libro (título, autor, año de publicación). Realiza la suma de dos números y guarda el resultado en una variable. Concatena dos cadenas de caracteres y muestra el resultado. 4.6 Flujo de control El flujo de control en Python se refiere a la secuencia en la que se ejecutan las instrucciones en un programa. Python ofrece varias estructuras de control que permiten tomar decisiones, repetir acciones y ejecutar código en función de condiciones específicas. 4.6.1 Estructuras de Control Condicionales 4.6.1.1 if Statement El if statement permite ejecutar un bloque de código si se cumple una condición. Por ejemplo: edad = 20 if edad &gt;= 18: print(&quot;Eres mayor de edad&quot;) ## Eres mayor de edad 4.6.1.2 if-else Statement El if-else statement ejecuta un bloque de código si se cumple una condición y otro bloque de código si la condición no se cumple. Por ejemplo: edad = 15 if edad &gt;= 18: print(&quot;Eres mayor de edad&quot;) else: print(&quot;Eres menor de edad&quot;) ## Eres menor de edad 4.6.1.3 if-elif-else Statement El if-elif-else statement permite evaluar múltiples condiciones de manera secuencial. Por ejemplo: puntuacion = 75 if puntuacion &gt;= 90: print(&quot;Excelente&quot;) elif puntuacion &gt;= 70: print(&quot;Bien&quot;) else: print(&quot;Puedes mejorar&quot;) ## Bien Ejercicios: Escribe un programa que verifique si un número es positivo, negativo o cero. Crea un programa que determine si un número es par o impar. 4.6.2 Estructuras de Control de Bucles 4.6.2.1 for Loop El bucle for itera sobre una secuencia, como una lista o una cadena de texto. Por ejemplo: for i in range(4): print(i) ## 0 ## 1 ## 2 ## 3 También podemos iterar sobre listas de caracteres. frutas = [&quot;manzana&quot;, &quot;banana&quot;, &quot;cereza&quot;] for fruta in frutas: print(fruta) ## manzana ## banana ## cereza for palabra in (&#39;genial&#39;, &#39;poderoso&#39;, &#39;legible&#39;): print(&#39;Python es %s&#39; % palabra) ## Python es genial ## Python es poderoso ## Python es legible 4.6.2.2 while Loop El bucle while ejecuta un bloque de código mientras se cumpla una condición. Por ejemplo: contador = 0 while contador &lt; 5: print(contador) contador += 1 ## 0 ## 1 ## 2 ## 3 ## 4 Ejercicios: Escribe un programa que muestre los números del 1 al 10 utilizando un bucle while. Crea un programa que calcule la suma de los números del 1 al 100 utilizando un bucle for. 4.6.3 Estructuras de Control de Interrupción 4.6.3.1 break Statement El break statement se utiliza para salir de un bucle antes de que se haya completado. Por ejemplo: for numero in range(10): if numero == 5: break print(numero) ## 0 ## 1 ## 2 ## 3 ## 4 4.6.3.2 continue Statement El continue statement se utiliza para saltar la iteración actual de un bucle y continuar con la siguiente. Por ejemplo: for numero in range(10): if numero == 5: continue print(numero) ## 0 ## 1 ## 2 ## 3 ## 4 ## 6 ## 7 ## 8 ## 9 Otro ejemplo: numeros = [2, 0, 5, 3, 0, 7] for numero in numeros: if numero == 0: continue print(f&quot;El inverso de {numero} es {1 / numero}&quot;) ## El inverso de 2 es 0.5 ## El inverso de 5 es 0.2 ## El inverso de 3 es 0.3333333333333333 ## El inverso de 7 es 0.14285714285714285 Ejercicios: Escribe un programa que encuentre el primer número divisible entre 7 y 5, entre 1500 y 2700. Crea un programa que imprima los números impares del 1 al 50, excepto aquellos que sean múltiplos de 3. 4.6.4 Expresiones condicionales Algunas expresiones condicionales que podemos usar en las estructuras de control son las siguientes: a == b: para comprobar igualdad entre dos objetos. Por ejemplo: 1==1 ## True a is b: para comprobar identidad entre ambos lados. Por ejemplo: 1 is 1 ## True a = 1 b = 1 a is b ## True a in b: Para ver si la colección b contiene a a. Por ejemplo: b = [1, 2, 3] 2 in b ## True 5 in b ## False En el caso de que b sea un diccionario, esto nos verifica si a es una llave de b. # Diccionario de nombres y edades b = {&#39;Juan&#39;: 30, &#39;María&#39;: 25, &#39;Pedro&#39;: 35} # Verificamos si &#39;Juan&#39; es una llave en el diccionario &#39;b&#39; if &#39;Juan&#39; in b: print(&#39;Juan está en el diccionario.&#39;) ## Juan está en el diccionario. # Verificamos si &#39;Ana&#39; es una llave en el diccionario &#39;b&#39; if &#39;Ana&#39; in b: print(&#39;Ana está en el diccionario.&#39;) else: print(&#39;Ana no está en el diccionario.&#39;) ## Ana no está en el diccionario. 4.6.5 Iteraciones sobre secuencias En Python, puedes iterar sobre cualquier secuencia, lo que incluye listas, tuplas, cadenas, diccionarios y conjuntos. La iteración te permite recorrer cada elemento de la secuencia uno por uno para realizar operaciones o tomar decisiones según cada elemento. vocales = &#39;aeiouy&#39; for letra in &#39;poderoso&#39;: if letra in vocales: print(letra) ## o ## e ## o ## o mensaje = &quot;Hola ¿cómo estás?&quot; palabras = mensaje.split() # retorna una lista for palabra in palabras: print(palabra) ## Hola ## ¿cómo ## estás? A veces queremos llevar un registro sobre lo que estamos iterando, una forma de hacerlo es con un for. colores = [&#39;rojo&#39;, &#39;verde&#39;, &#39;azul&#39;, &#39;amarillo&#39;] for i in range(0, len(colores)): print((i, colores[i])) ## (0, &#39;rojo&#39;) ## (1, &#39;verde&#39;) ## (2, &#39;azul&#39;) ## (3, &#39;amarillo&#39;) Otra forma de hacerlo es usando una función de python llamada enumerate. La función enumerate() en Python es una herramienta muy útil que te permite iterar sobre una secuencia mientras llevas un seguimiento del número de índice de cada elemento en la secuencia. La función enumerate() toma una secuencia (como una lista, tupla, cadena, etc.) y devuelve un objeto enumerado que genera pares de índice-elemento para cada elemento en la secuencia. Utilizando enumerate() con una lista: frutas = [&#39;manzana&#39;, &#39;banana&#39;, &#39;cereza&#39;, &#39;dátil&#39;] for indice, fruta in enumerate(frutas): print(f&#39;Índice: {indice}, Fruta: {fruta}&#39;) ## Índice: 0, Fruta: manzana ## Índice: 1, Fruta: banana ## Índice: 2, Fruta: cereza ## Índice: 3, Fruta: dátil En este ejemplo, enumerate(frutas) genera pares de índice-fruta para cada elemento en la lista frutas, y luego iteramos sobre estos pares. En cada iteración, indice contiene el índice del elemento y fruta contiene el valor del elemento. Utilizando enumerate() con una cadena: mensaje = &quot;Python es genial&quot; for indice, letra in enumerate(mensaje): print(f&#39;Índice: {indice}, Letra: {letra}&#39;) ## Índice: 0, Letra: P ## Índice: 1, Letra: y ## Índice: 2, Letra: t ## Índice: 3, Letra: h ## Índice: 4, Letra: o ## Índice: 5, Letra: n ## Índice: 6, Letra: ## Índice: 7, Letra: e ## Índice: 8, Letra: s ## Índice: 9, Letra: ## Índice: 10, Letra: g ## Índice: 11, Letra: e ## Índice: 12, Letra: n ## Índice: 13, Letra: i ## Índice: 14, Letra: a ## Índice: 15, Letra: l Aquí, enumerate(mensaje) genera pares de índice-letra para cada letra en la cadena mensaje. La función enumerate() es útil cuando necesitas iterar sobre una secuencia y necesitas saber tanto el índice como el valor del elemento en cada iteración. Es más legible y más eficiente que usar un contador y acceder a los elementos por índice. 4.6.6 Iteraciones sobre diccionarios También podemos iterar sobre un diccionario en Python, tanto sobre las claves, los valores, como sobre los pares clave-valor. Iterar sobre claves: Puedes iterar sobre las claves de un diccionario utilizando un bucle for. Por ejemplo: # Diccionario persona = {&#39;nombre&#39;: &#39;Juan&#39;, &#39;edad&#39;: 30, &#39;ciudad&#39;: &#39;Nueva York&#39;} # Iterar sobre las claves for clave in persona: print(clave) ## nombre ## edad ## ciudad Iterar sobre valores: De igual forma, puedes iterar sobre los valores de un diccionario utilizando un bucle for: # Iterar sobre los valores for valor in persona.values(): print(valor) ## Juan ## 30 ## Nueva York Iterar sobre pares clave-valor: Para iterar sobre las claves y valores simultáneamente, puedes usar el método items() del diccionario: # Iterar sobre pares clave-valor for clave, valor in persona.items(): print(clave, valor) ## nombre Juan ## edad 30 ## ciudad Nueva York Veamos otros ejemplos. Supongamos que tenemos un diccionario representando estudiantes y sus calificaciones: estudiantes = {&#39;Ana&#39;: 85, &#39;Beto&#39;: 90, &#39;Carlos&#39;: 80, &#39;Diana&#39;: 95} Ahora, podemos iterar sobre el diccionario para imprimir el nombre de cada estudiante junto con su calificación: for estudiante, calificacion in estudiantes.items(): print(f&#39;{estudiante}: {calificacion}&#39;) ## Ana: 85 ## Beto: 90 ## Carlos: 80 ## Diana: 95 4.6.7 Compresiones de listas Las comprensiones de listas son una característica poderosa de Python que te permite crear listas de forma concisa y legible utilizando una sintaxis compacta. La sintaxis general de una comprensión de lista es la siguiente: nueva_lista = [expresion for elemento in iterable if condicion] expresion: Es la expresión que define cómo se va a modificar o construir cada elemento de la nueva lista. elemento: Es la variable que representa cada elemento del iterable. iterable: Es la secuencia o iterable sobre la cual se va a iterar. condicion (opcional): Es una condición que filtra los elementos del iterable. Veamos algunos ejemplos. Crear una lista de los cuadrados de los primeros 10 números enteros: cuadrados = [x ** 2 for x in range(1, 11)] print(cuadrados) ## [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] Filtrar los números pares de una lista: numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] pares = [x for x in numeros if x % 2 == 0] print(pares) ## [2, 4, 6, 8, 10] Convertir una lista de cadenas a una lista de sus longitudes: palabras = [&#39;python&#39;, &#39;es&#39;, &#39;genial&#39;] longitudes = [len(palabra) for palabra in palabras] print(longitudes) ## [6, 2, 6] También es posible utilizar una condición else en una comprensión de lista. La sintaxis es la siguiente: resultado = [valor_verdadero if condicion else valor_falso for elemento in iterable] Por ejemplo: numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] resultado = [&#39;par&#39; if x % 2 == 0 else &#39;impar&#39; for x in numeros] print(resultado) ## [&#39;impar&#39;, &#39;par&#39;, &#39;impar&#39;, &#39;par&#39;, &#39;impar&#39;, &#39;par&#39;, &#39;impar&#39;, &#39;par&#39;, &#39;impar&#39;, &#39;par&#39;] Las comprensiones de listas son una forma elegante y eficiente de construir listas en Python. Son fáciles de leer y escribir, y pueden ayudarte a escribir código más limpio y conciso. Ejercicios: Ejercicio 1: Dada una lista de números, crea una lista que contenga los cuadrados de los números pares presentes en la lista dada. Ejercicio 2: Dada una lista de cadenas, crea una nueva lista que contenga todas las cadenas convertidas a mayúsculas. Por ejemplo, si tienes la lista siguiente: palabras = [&#39;hola&#39;, &#39;python&#39;, &#39;mundo&#39;, &#39;programación&#39;] Lo que quieres obtener es: [&#39;HOLA&#39;, &#39;PYTHON&#39;, &#39;MUNDO&#39;, &#39;PROGRAMACIÓN&#39;] Ejercicio 3: Dada una lista de números enteros, crea una lista que contenga solo los números primos de la lista dada, sin definir una función adicional. 4.7 Numpy NumPy es una librería fundamental para la computación científica en Python. Proporciona soporte para arrays multidimensionales, junto con una amplia colección de funciones matemáticas para trabajar con estos arrays. Ayuda a usar de manera eficiente la memoria ya que contien operaciones numéricas rápidas. Nota: Basado en Scientific Python Lectures y ASPP Latam. Para instalar NumPy, pueden utilizar pip, el gestor de paquetes de Python: pip install numpy Primero, importemos NumPy en nuestro entorno de trabajo. Por convención, numpy se suele importar de la siguiente forma: import numpy as np Podemos crear arreglos unidimensionales o multidimensionales. Por ejemplo, para crear un array unidimensional: arr_1d = np.array([1, 2, 3, 4, 5]) print(arr_1d) ## [1 2 3 4 5] Tenemos una función para crear array de ceros: np.zeros(10) ## array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]) Y arrays de unos: np.ones(10) ## array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]) Otra forma de crear array es usando secuencias con arange, por ejemplo: np.arange(10) ## array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) O usando una notación similar a las rebanas: arange(inicio, fin, salto): np.arange(9, -1, -1) ## array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) También podemos crearlos usando valores aleatorios: np.random.randint(0, 10, 5) ## array([9, 7, 8, 7, 5]) Para saber la dimensión, forma o longitud de nuestro array usamos lo siguiente: a = np.array([0,1,2,3,4,5]) print(a) ## [0 1 2 3 4 5] dimension = a.ndim print(dimension) ## 1 forma = a.shape print(forma) ## (6,) longitud = len(a) print(longitud) ## 6 Los arreglos multidimensionales, los podemos crear igual de varias maneras indicando las entradas de cada dimensión. Por ejemplo, para crear un array 2-dimensional de puros ceros, unos o random: np.zeros((2,10)) ## array([[0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], ## [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]]) np.ones((2,10)) ## array([[1., 1., 1., 1., 1., 1., 1., 1., 1., 1.], ## [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]]) np.random.randint(0, 10, (2, 10)) ## array([[5, 6, 4, 0, 8, 2, 2, 7, 0, 2], ## [2, 5, 0, 2, 3, 5, 8, 6, 5, 0]]) Otro array de dimensión dos puede ser el siguiente: arr_2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) print(arr_2d) ## [[1 2 3] ## [4 5 6] ## [7 8 9]] dimension = arr_2d.ndim print(dimension) ## 2 forma = arr_2d.shape print(forma) ## (3, 3) longitud = len(arr_2d) print(longitud) ## 3 De igual forma podemos usar arange: np.arange(2 * 10).reshape(2,10) ## array([[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9], ## [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]]) Otra forma de crear arrays es por medio de la función linspace, esto nos crea una colección de puntos, a esta función se le debe indicar el inicio, fin y cantidad de punto, por ejemplo: mi_array = np.linspace(0, 1, 6) print(mi_array) ## [0. 0.2 0.4 0.6 0.8 1. ] mi_array2 = np.linspace(0, 1, 5, endpoint = False) print(mi_array2) ## [0. 0.2 0.4 0.6 0.8] Otros dos arrays comunes son los diagonales: diag_unos = np.eye(3) print(diag_unos) ## [[1. 0. 0.] ## [0. 1. 0.] ## [0. 0. 1.]] diagonal = np.diag([1,2,3,4]) #diagonal = np.diag(np.array([1,2,3,4])) 4.7.1 Operaciones Básicas con NumPy Suma de Arrays arr1 = np.array([[1, 2], [3, 4]]) arr2 = np.array([[5, 6], [7, 8]]) sum_arr = arr1 + arr2 print(sum_arr) ## [[ 6 8] ## [10 12]] Producto de Arrays prod_arr = arr1 * arr2 print(prod_arr) ## [[ 5 12] ## [21 32]] Funciones Matemáticas: como calcular la raíz cuadrada sqrt_arr = np.sqrt(arr1) print(sqrt_arr) ## [[1. 1.41421356] ## [1.73205081 2. ]] Funciones Estadísticas: arr = np.array([1, 2, 3, 4, 5]) print(np.mean(arr)) # Media ## 3.0 print(np.median(arr)) # Mediana ## 3.0 print(np.std(arr)) # Desviación estándar ## 1.4142135623730951 Ejercicios Ejercicio 1: Crea un array unidimensional con los números del 1 al 10 e imprímelo. Ejercicio 2: Crea una matriz 3x3 con todos los elementos iguales a 5 e imprímela. Ejercicio 3: Calcula la suma de los elementos de la siguiente matriz: matriz = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 4.7.2 Indexación y Rebanado Como en las listas, los elementos de un array tiene un índice. Existen varias formas para indexar un array. Acceso a campos (field access indexing): Esta forma de indexación implica acceder a un elemento de un array multidimensional mediante una secuencia de índices separados por corchetes. Por ejemplo, a[1][2][3] significa que estás accediendo al elemento en la fila 1, columna 2 y profundidad 3 del array a. # para arreglos unidimensionales arr = np.array([1, 2, 3, 4, 5]) print(arr[2]) # Imprime el tercer elemento (índice 2) ## 3 print(arr[1:4]) # Imprime elementos desde el índice 1 hasta el 3 ## [2 3 4] # Crear un array tridimensional a = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]) # Acceder al elemento en la fila 1, columna 0, y profundidad 1 print(a[1][0][1]) # Imprime 8 ## 8 Indexación regular (regular indexing): En esta forma de indexación, los índices se proporcionan como una tupla separada por comas. Por ejemplo, a[1,2,3] significa que estás accediendo al elemento en la fila 1, columna 2 y profundidad 3 del array a. # Crear un array tridimensional a = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]) # Acceder al elemento en la fila 1, columna 0, y profundidad 1 print(a[1, 0, 1]) # Imprime 8 ## 8 Rebanado (slicing): Esta técnica implica seleccionar una parte del array utilizando rangos de índices. Por ejemplo, a[1:3, 1:3] significa que estás seleccionando las filas de la 1 a la 2 (exclusivo) y las columnas de la 1 a la 2 (exclusivo) del array a. # Crear un array bidimensional a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) # Seleccionar una parte del array print(a[1:3, 1:3]) # Imprime [[5 6] [8 9]] ## [[5 6] ## [8 9]] Indexación extravagante (fancy indexing): En esta forma de indexación, los índices se proporcionan como listas de índices. Por ejemplo, a[[1,2], [1,2]] significa que estás seleccionando los elementos con índices (1,1) y (2,2) del array a. # Crear un array bidimensional a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) # Seleccionar elementos con índices específicos print(a[[1, 2], [1, 2]]) # Imprime [5 9] ## [5 9] De esta forma también podemos asignar nuevos valores a nuestro array: a = np.arange(0, 100, 10) # extraemos unos valores: a[[2, 3, 2, 4, 2]] ## array([20, 30, 20, 40, 20]) # o modificamos algunos valores a[[9, 7]] = -100 a ## array([ 0, 10, 20, 30, 40, 50, 60, -100, 80, -100]) Imagen de Scientific Python Lectures, ver índice para la referencia. Otra forma de hacer este indexado fancy es usando boolean mask: # creamos un generador de numeros aleatorios con semilla 27 rng = np.random.default_rng(27446968) # creamos array con esos números aleatorios a1 = rng.integers(0, 21, 15) # Lo siguiente nos regresa un arreglo booleano (a1 % 3 == 0) ## array([ True, False, True, False, False, False, True, False, False, ## False, True, False, True, False, True]) # Creamos una máscara con esa condicion mascara = (a1 % 3 == 0) # extraemos usando esa máscara extraer_de_a1 = a1[mascara] extraer_de_a1 ## array([ 3, 12, 18, 6, 12, 3], dtype=int64) Se puede emplear esto de las máscaras para asignar nuevos valores: a1[a1 % 3 == 0] = -1 a1 ## array([-1, 13, -1, 10, 10, 10, -1, 4, 8, 5, -1, 11, -1, 17, -1], ## dtype=int64) Ejercicio 1: Considera es siguiente array, extrae usando este tipo de indexado las letras O,M,G y W, O, Z. np.array(list(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ1234&quot;)).reshape(5,6) ## array([[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;], ## [&#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;], ## [&#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;], ## [&#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;], ## [&#39;Y&#39;, &#39;Z&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;]], dtype=&#39;&lt;U1&#39;) Ejercicio 2: Considerea el siguiente array y extrae el array [ 5, 6, 7, 8, 9, 10, 11] usando una máscara boleana: np.arange(12).reshape(4,3) ## array([[ 0, 1, 2], ## [ 3, 4, 5], ## [ 6, 7, 8], ## [ 9, 10, 11]]) Existe un argumento llamado where que funciona con las funciones universales como suma, media, etc. a = np.arange(20).reshape(5,4) cond = a &gt;= 10 suma1 = np.sum(a[cond]) print(suma1) ## 145 suma2 = np.sum(a, where = cond) print(suma2) ## 145 4.7.3 Vistas y copias Vista (View): Una vista es una manera de acceder a los datos de un array NumPy sin copiar el buffer de datos subyacente. Esto significa que una vista comparte el mismo buffer de datos que el array original, pero puede tener una forma o una distribución de datos diferentes. Características: Acceso al array sin cambiar el buffer de datos. Indexación regular y rebanado generan vistas. Las operaciones in-place se pueden realizar en vistas. Copia (Copy): Una copia es una creación de un nuevo array que duplica tanto los datos como la metadata del array original. Esto significa que una copia tiene su propio buffer de datos independiente del array original. Características: Se crea un nuevo array duplicando tanto los datos como la metadata del array original. La indexación elegante siempre genera copias. Se puede forzar una copia utilizando el método .copy(). a = np.arange(1, 6) print(a) ## [1 2 3 4 5] # Crear una vista del array y imprimir su base v = a[2:5] # v es una vista print(v) ## [3 4 5] print(&#39;v.base:&#39;, v.base) # Devuelve el array &#39;base&#39; ## v.base: [1 2 3 4 5] a = np.arange(1, 6) print(a) ## [1 2 3 4 5] # Crear una copia del array # En este caso, utilizando indexación elegante v = a[[1, 2]] print(v) ## [2 3] # Cambiar un elemento en la copia y luego imprimir el array original v[0] = 99 print(&#39;v:&#39;, v) ## v: [99 3] print(&#39;a:&#39;, a) ## a: [1 2 3 4 5] Como observamos, al crear una copia real no se modifica el array original. Vamos a forzar una copia también: a = np.arange(1, 6) w = a.copy() w.base # vemos que indica None, lo que quiere decir es que no tiene como base # al array origianl, son idependientes w.base == None ## True Si usamos una vista: a = np.arange(1, 6) c = a[1:3] c[0] = 8 print(&#39;c:&#39;, c) ## c: [8 3] print(&#39;a:&#39;, a) ## a: [1 8 3 4 5] Es importante entender la diferencia entre una vista y una copia cuando trabajas con arrays en NumPy. Las operaciones en vistas pueden modificar el array original, mientras que las operaciones en copias no afectarán al array original. Esto puede ser crucial, especialmente cuando se realizan operaciones in-place o se manipulan grandes conjuntos de datos. 4.7.4 Ordenamiento La función de ordenamiento en NumPy se implementa con la función np.sort(). Por defecto, se utiliza el algoritmo de ordenamiento quicksort, que es muy eficiente. Características: np.sort() devuelve un array ordenado. .sort() realiza el ordenamiento in-place en el array original. Para ordenar en orden descendente, simplemente utiliza .flip() después de ordenar. Para ordenamiento de un array unidimensional: # Crear un array de números enteros aleatorios a = np.random.randint(1, 10, 5) print(&#39;Array original:&#39;, a) ## Array original: [3 8 9 5 9] # Ordenar el array y mostrar el resultado s = np.sort(a) print(&#39;Array ordenado:&#39;, s) ## Array ordenado: [3 5 8 9 9] # Ordenar in-place (en el mismo array) a.sort() print(&#39;Array original después de ordenar in-place:&#39;, a) ## Array original después de ordenar in-place: [3 5 8 9 9] Para ordenamiento de un array bidimensional: # Crear un array bidimensional de números enteros aleatorios a = np.random.randint(1, 15, (3,3)) print(&#39;Array original:&#39;) ## Array original: print(a) ## [[ 8 11 7] ## [11 1 1] ## [ 6 3 13]] # Ordenar por filas sorted_rows = np.sort(a) print(&#39;Array ordenado por filas:&#39;) ## Array ordenado por filas: print(sorted_rows) ## [[ 7 8 11] ## [ 1 1 11] ## [ 3 6 13]] # Ordenar por columnas sorted_cols = np.sort(a, axis=0) print(&#39;Array ordenado por columnas:&#39;) ## Array ordenado por columnas: print(sorted_cols) ## [[ 6 1 1] ## [ 8 3 7] ## [11 11 13]] Otra función de ordenamiento es argsort: # Crear un array de números enteros aleatorios a = np.random.randint(1, 15, 10) print(&#39;Array original:&#39;, a) ## Array original: [ 6 3 7 6 13 13 3 8 7 7] # Obtener los índices que ordenarían el array indices_ordenados = np.argsort(a) print(&#39;Índices ordenados:&#39;, indices_ordenados) ## Índices ordenados: [1 6 0 3 2 8 9 7 4 5] # Ordenar el array utilizando indexación elegante sorted_array = a[indices_ordenados] print(&#39;Array ordenado con indexación elegante:&#39;) ## Array ordenado con indexación elegante: print(sorted_array) ## [ 3 3 6 6 7 7 7 8 13 13] La función de ordenamiento en NumPy es una herramienta poderosa para ordenar arrays de manera eficiente, tanto en una como en varias dimensiones. Al entender cómo utilizar np.sort() y argsort(), puedes ordenar tus datos según tus necesidades específicas, ya sea en orden ascendente o descendente. Además, ten en cuenta que el argumento axis te permite ordenar por filas o columnas, según sea necesario. Ejercicio 1: Para el array a=np.ones((5,5,5)), responde lo siguiente para cada caso: ¿Cuál es su dimensión? ¿Es una vista o una copia? Después verifica tu respuesta. v = a[1, ::2, ::2] v = a[2,:] v = a[[0, 1],:] v = a[[2,3], [2,3]] Ejercicio 2: Recrea los siguientes plots usando lo siguiente: Realiza un array de solo ceros que será tu base. Cambia los valores correspondientes a 1. Usa plt.matshow(nombre_array) para hacer el plot. Para importar el paquete para hacer el plot realiza lo siguiente: %matplotlib inline from matplotlib import pyplot as plt #libreria para hacer plots Ejercicio de ASPP Latam Ejercicio 3: Comienza creando un array 3x3: ej = np.array([[6,2,3], [1,7,2], [7,6,5]]) ej ## array([[6, 2, 3], ## [1, 7, 2], ## [7, 6, 5]]) Ordena la última fila en forma ascenderte de manera in-place. Ahora, ordena la primera y segunda columna (ascendentemente) de dos formas distintas: Usando fancy-index in-place, usando rebanadas o índices. 4.7.5 Broadcasting El broadcasting es una poderosa característica de NumPy que permite realizar operaciones aritméticas entre arrays de diferentes formas sin necesidad de que tengan las mismas dimensiones. Esto significa que NumPy puede manejar automáticamente situaciones donde las dimensiones de los arrays no coinciden, pero pueden ser compatibles de alguna manera. Cuando se realizan operaciones aritméticas entre dos arrays, NumPy sigue un conjunto de reglas para determinar si las formas de los arrays son compatibles para la operación de broadcasting. Las reglas son las siguientes: Si los arrays tienen un número diferente de dimensiones, se les agrega una dimensión extra en el lado izquierdo hasta que ambos tengan el mismo número de dimensiones. Si las formas de los arrays no coinciden en alguna dimensión, NumPy ajustará las dimensiones de tamaño 1 para que coincidan en esa dimensión. Después de aplicar las reglas 1 y 2, los tamaños de las dimensiones de ambos arrays deben coincidir. Si alguna dimensión tiene un tamaño diferente y no es 1, se producirá un error. Ejemplo 1: Suma de un escalar a un array # Crear un array de forma (3, 3) a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) # Sumar un escalar (5) a cada elemento del array resultado = a + 5 print(resultado) ## [[ 6 7 8] ## [ 9 10 11] ## [12 13 14]] Ejemplo 2: Suma de dos arrays con diferentes formas # Crear dos arrays con diferentes formas a = np.array([[1, 2, 3], [4, 5, 6]]) b = np.array([10, 20, 30]) # Sumar ambos arrays resultado = a + b print(resultado) ## [[11 22 33] ## [14 25 36]] Ejemplo 3: Multiplicación de arrays con formas compatibles # Crear dos arrays con formas compatibles a = np.array([[1], [2], [3]]) b = np.array([1, 2, 3]) # Multiplicar ambos arrays resultado = a * b print(resultado) ## [[1 2 3] ## [2 4 6] ## [3 6 9]] El broadcasting es una característica poderosa de NumPy que simplifica las operaciones entre arrays con diferentes formas. Al entender las reglas de broadcasting, puedes realizar operaciones aritméticas de manera eficiente y elegante en NumPy, lo que facilita el trabajo con datos multidimensionales en Python. 4.8 Visualización de datos Matplotlib es la biblioteca principal de visualización de datos en Python. Proporciona una amplia gama de funciones y herramientas para crear diversos tipos de gráficos, como gráficos de líneas, de dispersión, de barras, de pastel, entre otros. Matplotlib también es altamente personalizable, lo que te permite ajustar casi todos los aspectos de tus gráficos. matplotlib.pyplot es un módulo dentro de Matplotlib que proporciona una interfaz de estilo MATLAB para crear gráficos, proporciona una interfaz orientada a objetos. Simplifica la creación de gráficos al proporcionar una serie de funciones que permiten generar rápidamente gráficos simples. Para instalarlo podemos realizar lo siguiente: pip install matplotlib Antes de comenzar, debemos importarlo. Vamos a usar los alias usuales para importarlo. import matplotlib as mpl import matplotlib.pyplot as plt import numpy as np Cuando se trabaja con Matplotlib, los datos se representan en lo que se llama “Figuras”. Una figura puede entenderse como una ventana o un lienzo en el cual se puede dibujar un gráfico. Cada figura puede contener uno o más “Ejes” (Axes), que es el área donde se puede especificar puntos en términos de coordenadas x-y. Por ejemplo, si están trabajando en un gráfico de dispersión bidimensional, los ejes representarían el plano cartesiano donde pueden colocar sus puntos de datos. Si están haciendo un gráfico de barras, los ejes representarían los ejes x, y donde se dibujarían las barras. Una de las formas más simples de crear una figura con ejes en Matplotlib es utilizando la función pyplot.subplots(). Esta función crea una nueva figura y devuelve una tupla que contiene la figura y un solo conjunto de ejes. Luego, se pueden utilizar los métodos asociados con los ejes para dibujar datos en la figura. Por ejemplo, la función Axes.plot() se utiliza para dibujar una línea o un marcador en los ejes. Pueden pasar sus datos de x,y como argumentos a esta función y Matplotlib dibujará los puntos correspondientes en el gráfico. Una figura está formada por las siguientes partes: Imagen del tutorial de Matplotlib Matplotlib espera que los datos de entrada sean de tipo numpy.array o numpy.ma.masked_array, o bien objetos que puedan convertirse en numpy.array utilizando la función numpy.asarray(). Estos tipos de datos son adecuados porque Matplotlib está integrado con NumPy y puede trabajar eficientemente con arreglos NumPy para realizar operaciones de trazado. Sin embargo, hay otros tipos de datos que son similares a los arreglos pero que Matplotlib puede no entender correctamente. Por ejemplo: Objetos de datos de pandas: Aunque pandas es una biblioteca popular para el análisis de datos en Python, los objetos de datos de pandas, como Series y DataFrame, no son directamente compatibles con Matplotlib. Aunque puedes trazar datos de pandas directamente, a veces puede haber problemas de compatibilidad o resultados inesperados. Objetos de matriz de NumPy (numpy.matrix): Aunque los objetos de matriz de NumPy son similares a los arreglos de NumPy, pueden tener un comportamiento ligeramente diferente en algunas operaciones, lo que puede causar problemas al trazar datos. La convención común para evitar estos problemas es convertir estos objetos de datos “similares a arreglos” en arreglos NumPy utilizando numpy.array() antes de trazarlos. Esto garantiza una mayor compatibilidad y evita posibles problemas de trazado. 4.8.1 Bases de un plot Los dos enfoques principales para utilizar Matplotlib son: 1. Interfaz explícita u orientada a objetos (OO) En este enfoque, tú creas explícitamente las figuras (Figure) y los ejes (Axes), y luego llamas a los métodos asociados con ellos para personalizar y agregar elementos a tus gráficos. Este enfoque se conoce como el “estilo orientado a objetos (OO)”. Por ejemplo, puedes crear una figura y ejes usando plt.subplots() y luego llamar a métodos como ax.plot() o ax.scatter() para trazar tus datos en los ejes. Este enfoque es más flexible y poderoso, especialmente para gráficos más complejos o cuando deseas realizar modificaciones detalladas en tus gráficos. Por ejemplo: # Creamos una figura y ejes utilizando plt.subplots() fig, ax = plt.subplots() # Datos x = np.linspace(-5, 5, 100) # Utilizamos Axes.plot() para dibujar los datos en los ejes ax.plot(x, x**2, label= &quot;$x^2$&quot;) ax.plot(x, -x**2+5, label= &quot;$-x^2+5$&quot;) # Configuramos ejes, título y legendas ax.set_xlabel(&#39;Eje X&#39;) ax.set_ylabel(&#39;Eje Y&#39;) ax.set_title(&#39;Gráfico de funciones cuadráticas&#39;) ax.legend() # Mostramos el gráfico plt.show() 2. Interfaz implícita o estilo de pyplot En este enfoque, confías en la interfaz pyplot para crear y gestionar implícitamente las figuras y los ejes en segundo plano. Utilizas las funciones de pyplot para realizar tareas como crear figuras, trazar datos y personalizar gráficos. Por ejemplo, puedes llamar a funciones como plt.plot() o plt.scatter() directamente para trazar tus datos sin necesidad de crear explícitamente una figura y ejes. Este enfoque es más conveniente para gráficos simples y rápidos, pero puede ser menos flexible cuando necesitas realizar modificaciones detalladas en tus gráficos. # Creamos nuestra base del plot x = np.linspace(-5, 5, 40) # Definimos las funciones para hacer el plot fx, gx = x**2, -x**2+5 # Usamos la función plot de pyplot indicando eje X y eje y plt.plot(x, fx, label= &quot;$x^2$&quot;) plt.plot(x, gx, label= &quot;$-x^2 + 5$&quot;) plt.xlabel(&#39;Eje X&#39;) plt.ylabel(&#39;Eje Y&#39;) plt.title(&#39;Gráfico de funciones cuadráticas&#39;) plt.legend() # Mostramos el plot plt.show() 4.8.1.1 Colores y tipos de líneas Tipos de líneas, imagen de la Cheatsheets de Matplotlib # Creamos nuestra base del plot x = np.linspace(-5, 5, 40) # Definimos las funciones para hacer el plot fx, gx = x**2, -x**2+5 #Cambiamos tamaño de figura plt.figure(figsize=(10,6), dpi=80) # Configuramos color y tipo de línea plt.plot(x, fx, color=&quot;red&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label= &quot;$x^2$&quot;) plt.plot(x, gx, color=&quot;green&quot;, linewidth=2.5, linestyle=&quot;--&quot;, label= &quot;$-x^2 + 5$&quot;) # Añadimos títulos al eje X, Y y título del plot plt.xlabel(&#39;Eje X&#39;) plt.ylabel(&#39;Eje Y&#39;) plt.title(&#39;Gráfico de funciones cuadráticas&#39;) plt.legend() # Mostramos el plot plt.show() 4.8.1.2 Configurar los límites de los ejes x = np.linspace(-5, 5, 40) # Definimos las funciones para hacer el plot fx, gx = x**2, -x**2+5 #Cambiamos tamaño de figura plt.figure(figsize=(10,6), dpi=80) # Configuramos color y tipo de línea plt.plot(x, fx, color=&quot;red&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label= &quot;$x^2$&quot;) plt.plot(x, gx, color=&quot;green&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label= &quot;$-x^2 + 5$&quot;) # Configuramos límites de los ejes plt.xlim(-6,6) ## (-6.0, 6.0) plt.ylim(fx.min()*1.1, fx.max()*1.1) ## (0.018080210387902567, 27.500000000000004) #plt.ylim(gx.min()*1.1, fx.max()*1.1) # Añadimos títulos al eje X, Y y título del plot plt.xlabel(&#39;Eje X&#39;) plt.ylabel(&#39;Eje Y&#39;) plt.title(&#39;Gráfico de funciones cuadráticas&#39;) plt.legend() # Mostramos el plot plt.show() 4.8.1.3 Configuración de ticks x = np.linspace(-5, 5, 40) # Definimos las funciones para hacer el plot fx, gx = x**2, -x**2+5 #Cambiamos tamaño de figura plt.figure(figsize=(10,10), dpi=80) # Configuramos color y tipo de línea plt.plot(x, fx, color=&quot;red&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label= &quot;$x^2$&quot;) plt.plot(x, gx, color=&quot;green&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label= &quot;$-x^2 + 5$&quot;) # Configuramos límites de los ejes plt.xlim(-6,6) ## (-6.0, 6.0) plt.ylim(gx.min()*1.1, fx.max()*1.1) ## (-22.0, 27.500000000000004) # Configuración de ticks plt.xticks(np.arange(-5,6,1)) ## ([&lt;matplotlib.axis.XTick object at 0x0000025028803910&gt;, &lt;matplotlib.axis.XTick object at 0x00000250288003D0&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028675DD0&gt;, &lt;matplotlib.axis.XTick object at 0x00000250234CFED0&gt;, &lt;matplotlib.axis.XTick object at 0x000002502884E910&gt;, &lt;matplotlib.axis.XTick object at 0x000002502884FB50&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028849650&gt;, &lt;matplotlib.axis.XTick object at 0x000002502884B690&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028DB9650&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028DBB510&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028DBA050&gt;], [Text(-5, 0, &#39;−5&#39;), Text(-4, 0, &#39;−4&#39;), Text(-3, 0, &#39;−3&#39;), Text(-2, 0, &#39;−2&#39;), Text(-1, 0, &#39;−1&#39;), Text(0, 0, &#39;0&#39;), Text(1, 0, &#39;1&#39;), Text(2, 0, &#39;2&#39;), Text(3, 0, &#39;3&#39;), Text(4, 0, &#39;4&#39;), Text(5, 0, &#39;5&#39;)]) plt.yticks(np.arange(-20,30,5)) ## ([&lt;matplotlib.axis.YTick object at 0x00000250287D2010&gt;, &lt;matplotlib.axis.YTick object at 0x00000250287ACD90&gt;, &lt;matplotlib.axis.YTick object at 0x00000250287AC050&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028DBFF50&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028DCE0D0&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028DD00D0&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028DD0A90&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028DD2810&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028DD8710&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028DDA610&gt;], [Text(0, -20, &#39;−20&#39;), Text(0, -15, &#39;−15&#39;), Text(0, -10, &#39;−10&#39;), Text(0, -5, &#39;−5&#39;), Text(0, 0, &#39;0&#39;), Text(0, 5, &#39;5&#39;), Text(0, 10, &#39;10&#39;), Text(0, 15, &#39;15&#39;), Text(0, 20, &#39;20&#39;), Text(0, 25, &#39;25&#39;)]) # Añadimos títulos al eje X, Y y título del plot plt.xlabel(&#39;Eje X&#39;) plt.ylabel(&#39;Eje Y&#39;) plt.title(&#39;Gráfico de funciones cuadráticas&#39;) plt.legend() # Mostramos el plot plt.show() 4.8.1.4 Configurar label de los ticks x = np.linspace(-5, 5, 40) # Definimos las funciones para hacer el plot fx, gx = x**2, -x**2+5 #Cambiamos tamaño de figura plt.figure(figsize=(10,10), dpi=80) # Configuramos color y tipo de línea plt.plot(x, fx, color=&quot;red&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label= &quot;$x^2$&quot;) plt.plot(x, gx, color=&quot;green&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label= &quot;$-x^2 + 5$&quot;) # Configuramos límites de los ejes plt.xlim(-6,6) ## (-6.0, 6.0) plt.ylim(gx.min()*1.1, fx.max()*1.1) ## (-22.0, 27.500000000000004) # Configuración de ticks plt.xticks(np.arange(-2,3,0.5)) ## ([&lt;matplotlib.axis.XTick object at 0x0000025028E3A150&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028E16DD0&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028E3CBD0&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028E22850&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028E7D1D0&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028E7E550&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028E74110&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028E76090&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028E8C110&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028E8DF10&gt;], [Text(-2.0, 0, &#39;−2.0&#39;), Text(-1.5, 0, &#39;−1.5&#39;), Text(-1.0, 0, &#39;−1.0&#39;), Text(-0.5, 0, &#39;−0.5&#39;), Text(0.0, 0, &#39;0.0&#39;), Text(0.5, 0, &#39;0.5&#39;), Text(1.0, 0, &#39;1.0&#39;), Text(1.5, 0, &#39;1.5&#39;), Text(2.0, 0, &#39;2.0&#39;), Text(2.5, 0, &#39;2.5&#39;)]) plt.yticks(np.arange(-20,30,5)) ## ([&lt;matplotlib.axis.YTick object at 0x0000025028E20E10&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028E23750&gt;, &lt;matplotlib.axis.YTick object at 0x00000250284DD250&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028E94850&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028E96A10&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028E98910&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028E9A810&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028E7D9D0&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028E172D0&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028721710&gt;], [Text(0, -20, &#39;−20&#39;), Text(0, -15, &#39;−15&#39;), Text(0, -10, &#39;−10&#39;), Text(0, -5, &#39;−5&#39;), Text(0, 0, &#39;0&#39;), Text(0, 5, &#39;5&#39;), Text(0, 10, &#39;10&#39;), Text(0, 15, &#39;15&#39;), Text(0, 20, &#39;20&#39;), Text(0, 25, &#39;25&#39;)]) # Añadimos títulos al eje X, Y y título del plot plt.xlabel(&#39;Eje X&#39;) plt.ylabel(&#39;Eje Y&#39;) plt.title(&#39;Gráfico de funciones cuadráticas&#39;) plt.legend() # Mostramos el plot plt.show() x = np.linspace(-5, 5, 40) # Definimos las funciones para hacer el plot fx, gx = x**2, -x**2+5 #Cambiamos tamaño de figura plt.figure(figsize=(10,10), dpi=80) # Configuramos color y tipo de línea plt.plot(x, fx, color=&quot;red&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label= &quot;$x^2$&quot;) plt.plot(x, gx, color=&quot;green&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label= &quot;$-x^2 + 5$&quot;) # Configuramos límites de los ejes plt.xlim(-6,6) ## (-6.0, 6.0) plt.ylim(gx.min()*1.1, fx.max()*1.1) ## (-22.0, 27.500000000000004) # Configuración del label de los ticks plt.xticks(np.arange(-2,3,0.5), [r&#39;$-2$&#39;, r&#39;$-\\frac{3}{2}$&#39;, r&#39;$-1$&#39;, r&#39;$-\\frac{1}{2}$&#39;, r&#39;$0$&#39;,r&#39;$\\frac{1}{2}$&#39;, r&#39;$1$&#39;, r&#39;$\\frac{3}{2}$&#39;, r&#39;$2$&#39;, r&#39;$\\frac{5}{2}$&#39;]) ## ([&lt;matplotlib.axis.XTick object at 0x0000025028E02290&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028756DD0&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028837350&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028698A10&gt;, &lt;matplotlib.axis.XTick object at 0x000002502876BA10&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028496150&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028499D50&gt;, &lt;matplotlib.axis.XTick object at 0x0000025029F65010&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028E7F610&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028E64410&gt;], [Text(-2.0, 0, &#39;$-2$&#39;), Text(-1.5, 0, &#39;$-\\\\frac{3}{2}$&#39;), Text(-1.0, 0, &#39;$-1$&#39;), Text(-0.5, 0, &#39;$-\\\\frac{1}{2}$&#39;), Text(0.0, 0, &#39;$0$&#39;), Text(0.5, 0, &#39;$\\\\frac{1}{2}$&#39;), Text(1.0, 0, &#39;$1$&#39;), Text(1.5, 0, &#39;$\\\\frac{3}{2}$&#39;), Text(2.0, 0, &#39;$2$&#39;), Text(2.5, 0, &#39;$\\\\frac{5}{2}$&#39;)]) plt.yticks(np.arange(-20,30,5)) ## ([&lt;matplotlib.axis.YTick object at 0x0000025029F89C90&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028800310&gt;, &lt;matplotlib.axis.YTick object at 0x0000025029F8B550&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028E75490&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028E77990&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028E8DF50&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028E8DFD0&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028E4C1D0&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028E4E710&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028E209D0&gt;], [Text(0, -20, &#39;−20&#39;), Text(0, -15, &#39;−15&#39;), Text(0, -10, &#39;−10&#39;), Text(0, -5, &#39;−5&#39;), Text(0, 0, &#39;0&#39;), Text(0, 5, &#39;5&#39;), Text(0, 10, &#39;10&#39;), Text(0, 15, &#39;15&#39;), Text(0, 20, &#39;20&#39;), Text(0, 25, &#39;25&#39;)]) # Añadimos títulos al eje X, Y y título del plot plt.xlabel(&#39;Eje X&#39;) plt.ylabel(&#39;Eje Y&#39;) plt.title(&#39;Gráfico de funciones cuadráticas&#39;) plt.legend() # Mostramos el plot plt.show() 4.8.1.5 Mover los “spines” Los “spines” en Matplotlib son las líneas que conectan las marcas de los ejes y delimitan el área de los datos en un gráfico. Hay cuatro “spines” en total: superior, inferior, izquierdo y derecho. Tradicionalmente, los “spines” están ubicados en los bordes del área de los datos. La idea de cambiar la posición de los “spines” es tenerlos en el centro del gráfico, en lugar de en los bordes. Esto puede ser útil para ciertos tipos de gráficos donde se desea resaltar la región central del gráfico. Descartar los “spines” superior y derecho: Para eliminar los “spines” superior y derecho, se establece su color en “none”, lo que hace que sean transparentes y no visibles en el gráfico. Mover los “spines” inferior y izquierdo al origen de coordenadas de los datos: Esto significa que los “spines” inferior y izquierdo se moverán para que se encuentren en la posición donde los valores de los ejes x e y son cero, respectivamente. Esto se hace para colocar los “spines” en el centro del gráfico. x = np.linspace(-5, 5, 40) # Definimos las funciones para hacer el plot fx, gx = x**2, -x**2+5 #Cambiamos tamaño de figura plt.figure(figsize=(10,10), dpi=80) # Configuramos color y tipo de línea plt.plot(x, fx, color=&quot;red&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label= &quot;$x^2$&quot;) plt.plot(x, gx, color=&quot;green&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label= &quot;$-x^2 + 5$&quot;) # Configuramos límites de los ejes plt.xlim(-6,6) ## (-6.0, 6.0) plt.ylim(gx.min()*1.1, fx.max()*1.1) ## (-22.0, 27.500000000000004) # Configuración del label de los ticks plt.xticks(np.arange(-2,3,0.5), [r&#39;$-2$&#39;, r&#39;$-\\frac{3}{2}$&#39;, r&#39;$-1$&#39;, r&#39;$-\\frac{1}{2}$&#39;, r&#39;$0$&#39;,r&#39;$\\frac{1}{2}$&#39;, r&#39;$1$&#39;, r&#39;$\\frac{3}{2}$&#39;, r&#39;$2$&#39;, r&#39;$\\frac{5}{2}$&#39;]) ## ([&lt;matplotlib.axis.XTick object at 0x00000250287E0A90&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028787190&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028E4D690&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028805DD0&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028835150&gt;, &lt;matplotlib.axis.XTick object at 0x00000250287C7590&gt;, &lt;matplotlib.axis.XTick object at 0x00000250287C6390&gt;, &lt;matplotlib.axis.XTick object at 0x00000250287D1910&gt;, &lt;matplotlib.axis.XTick object at 0x00000250287C4750&gt;, &lt;matplotlib.axis.XTick object at 0x00000250287D2550&gt;], [Text(-2.0, 0, &#39;$-2$&#39;), Text(-1.5, 0, &#39;$-\\\\frac{3}{2}$&#39;), Text(-1.0, 0, &#39;$-1$&#39;), Text(-0.5, 0, &#39;$-\\\\frac{1}{2}$&#39;), Text(0.0, 0, &#39;$0$&#39;), Text(0.5, 0, &#39;$\\\\frac{1}{2}$&#39;), Text(1.0, 0, &#39;$1$&#39;), Text(1.5, 0, &#39;$\\\\frac{3}{2}$&#39;), Text(2.0, 0, &#39;$2$&#39;), Text(2.5, 0, &#39;$\\\\frac{5}{2}$&#39;)]) plt.yticks([-20,-10,10,20],[r&#39;$-20$&#39;, r&#39;$-10$&#39;, r&#39;$+10$&#39;, r&#39;$+20$&#39;]) ## ([&lt;matplotlib.axis.YTick object at 0x00000250287E20D0&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028E00C90&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028E0DDD0&gt;, &lt;matplotlib.axis.YTick object at 0x000002502878CFD0&gt;], [Text(0, -20, &#39;$-20$&#39;), Text(0, -10, &#39;$-10$&#39;), Text(0, 10, &#39;$+10$&#39;), Text(0, 20, &#39;$+20$&#39;)]) # Mover los spines ax = plt.gca() # obtener los ejes actuales ax.spines[&#39;right&#39;].set_color(&#39;none&#39;) ax.spines[&#39;top&#39;].set_color(&#39;none&#39;) ax.spines[&#39;bottom&#39;].set_position(&#39;zero&#39;) ax.spines[&#39;left&#39;].set_position(&#39;zero&#39;) # Otra forma de lograr lo anterior #ax.xaxis.set_ticks_position(&#39;bottom&#39;) #ax.spines[&#39;bottom&#39;].set_position((&#39;data&#39;,0)) #ax.yaxis.set_ticks_position(&#39;left&#39;) #ax.spines[&#39;left&#39;].set_position((&#39;data&#39;,0)) # Añadimos títulos al eje X, Y y título del plot plt.xlabel(&#39;Eje X&#39;) plt.ylabel(&#39;Eje Y&#39;) plt.title(&#39;Gráfico de funciones cuadráticas&#39;) plt.legend() # Mostramos el plot plt.show() 4.8.1.6 Añadir y configurar legendas Posición de legendas, imagen de las Cheatsheets de Matplotlib x = np.linspace(-5, 5, 40) # Definimos las funciones para hacer el plot fx, gx = x**2, -x**2+5 #Cambiamos tamaño de figura plt.figure(figsize=(10,10), dpi=80) # Configuramos color y tipo de línea plt.plot(x, fx, color=&quot;red&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label= &quot;$x^2$&quot;) plt.plot(x, gx, color=&quot;green&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label= &quot;$-x^2 + 5$&quot;) # Configuramos límites de los ejes plt.xlim(-6,6) ## (-6.0, 6.0) plt.ylim(gx.min()*1.1, fx.max()*1.1) ## (-22.0, 27.500000000000004) # Configuración del label de los ticks plt.xticks(np.arange(-2,3,0.5), [r&#39;$-2$&#39;, r&#39;$-\\frac{3}{2}$&#39;, r&#39;$-1$&#39;, r&#39;$-\\frac{1}{2}$&#39;, r&#39;$0$&#39;,r&#39;$\\frac{1}{2}$&#39;, r&#39;$1$&#39;, r&#39;$\\frac{3}{2}$&#39;, r&#39;$2$&#39;, r&#39;$\\frac{5}{2}$&#39;]) ## ([&lt;matplotlib.axis.XTick object at 0x00000250286D4AD0&gt;, &lt;matplotlib.axis.XTick object at 0x000002502874EDD0&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028DD3DD0&gt;, &lt;matplotlib.axis.XTick object at 0x00000250286EDA90&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028736A90&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028702DD0&gt;, &lt;matplotlib.axis.XTick object at 0x00000250287BE010&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028829110&gt;, &lt;matplotlib.axis.XTick object at 0x0000025029F89950&gt;, &lt;matplotlib.axis.XTick object at 0x00000250287833D0&gt;], [Text(-2.0, 0, &#39;$-2$&#39;), Text(-1.5, 0, &#39;$-\\\\frac{3}{2}$&#39;), Text(-1.0, 0, &#39;$-1$&#39;), Text(-0.5, 0, &#39;$-\\\\frac{1}{2}$&#39;), Text(0.0, 0, &#39;$0$&#39;), Text(0.5, 0, &#39;$\\\\frac{1}{2}$&#39;), Text(1.0, 0, &#39;$1$&#39;), Text(1.5, 0, &#39;$\\\\frac{3}{2}$&#39;), Text(2.0, 0, &#39;$2$&#39;), Text(2.5, 0, &#39;$\\\\frac{5}{2}$&#39;)]) plt.yticks([-20,-10,10,20],[r&#39;$-20$&#39;, r&#39;$-10$&#39;, r&#39;$+10$&#39;, r&#39;$+20$&#39;]) ## ([&lt;matplotlib.axis.YTick object at 0x00000250288365D0&gt;, &lt;matplotlib.axis.YTick object at 0x000002502874EBD0&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028663C50&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028823BD0&gt;], [Text(0, -20, &#39;$-20$&#39;), Text(0, -10, &#39;$-10$&#39;), Text(0, 10, &#39;$+10$&#39;), Text(0, 20, &#39;$+20$&#39;)]) # Mover los spines ax = plt.gca() # obtener los ejes actuales ax.spines[&#39;right&#39;].set_color(&#39;none&#39;) ax.spines[&#39;top&#39;].set_color(&#39;none&#39;) ax.spines[&#39;bottom&#39;].set_position(&#39;zero&#39;) ax.spines[&#39;left&#39;].set_position(&#39;zero&#39;) # Otra forma de lograr lo anterior #ax.xaxis.set_ticks_position(&#39;bottom&#39;) #ax.spines[&#39;bottom&#39;].set_position((&#39;data&#39;,0)) #ax.yaxis.set_ticks_position(&#39;left&#39;) #ax.spines[&#39;left&#39;].set_position((&#39;data&#39;,0)) # Añadimos títulos al eje X, Y y título del plot plt.xlabel(&#39;Eje X&#39;) plt.ylabel(&#39;Eje Y&#39;) plt.title(&#39;Gráfico de funciones cuadráticas&#39;) # Configurar posición de la leyenda plt.legend(loc = &#39;center left&#39;) #Otras configuraciones #plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.) #plt.legend(bbox_to_anchor=(0., 1.02, 1., .102), loc=0, ncol=2, mode=&quot;expand&quot;, borderaxespad=0.) #plt.legend(bbox_to_anchor=(1, 1), bbox_transform=plt.gcf().transFigure) # Mostramos el plot plt.show() Se pueden poner por separado también: x = np.linspace(-5, 5, 40) # Definimos las funciones para hacer el plot fx, gx = x**2, -x**2+5 #Cambiamos tamaño de figura plt.figure(figsize=(10,10), dpi=80) # Configuramos color y tipo de línea line1, = plt.plot(x, fx, color=&quot;red&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label= &quot;$x^2$&quot;) line2, = plt.plot(x, gx, color=&quot;green&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label= &quot;$-x^2 + 5$&quot;) # Configuramos límites de los ejes plt.xlim(-6,6) ## (-6.0, 6.0) plt.ylim(gx.min()*1.1, fx.max()*1.1) ## (-22.0, 27.500000000000004) # Configuración del label de los ticks plt.xticks(np.arange(-2,3,0.5), [r&#39;$-2$&#39;, r&#39;$-\\frac{3}{2}$&#39;, r&#39;$-1$&#39;, r&#39;$-\\frac{1}{2}$&#39;, r&#39;$0$&#39;,r&#39;$\\frac{1}{2}$&#39;, r&#39;$1$&#39;, r&#39;$\\frac{3}{2}$&#39;, r&#39;$2$&#39;, r&#39;$\\frac{5}{2}$&#39;]) ## ([&lt;matplotlib.axis.XTick object at 0x000002502884D250&gt;, &lt;matplotlib.axis.XTick object at 0x00000250284A5550&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028E75CD0&gt;, &lt;matplotlib.axis.XTick object at 0x00000250234CB510&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028776810&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028821490&gt;, &lt;matplotlib.axis.XTick object at 0x00000250287D41D0&gt;, &lt;matplotlib.axis.XTick object at 0x00000250286B41D0&gt;, &lt;matplotlib.axis.XTick object at 0x00000250287F3710&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028769C90&gt;], [Text(-2.0, 0, &#39;$-2$&#39;), Text(-1.5, 0, &#39;$-\\\\frac{3}{2}$&#39;), Text(-1.0, 0, &#39;$-1$&#39;), Text(-0.5, 0, &#39;$-\\\\frac{1}{2}$&#39;), Text(0.0, 0, &#39;$0$&#39;), Text(0.5, 0, &#39;$\\\\frac{1}{2}$&#39;), Text(1.0, 0, &#39;$1$&#39;), Text(1.5, 0, &#39;$\\\\frac{3}{2}$&#39;), Text(2.0, 0, &#39;$2$&#39;), Text(2.5, 0, &#39;$\\\\frac{5}{2}$&#39;)]) plt.yticks([-20,-10,10,20],[r&#39;$-20$&#39;, r&#39;$-10$&#39;, r&#39;$+10$&#39;, r&#39;$+20$&#39;]) ## ([&lt;matplotlib.axis.YTick object at 0x000002502882B910&gt;, &lt;matplotlib.axis.YTick object at 0x00000250284A7210&gt;, &lt;matplotlib.axis.YTick object at 0x00000250284A23D0&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028E9A5D0&gt;], [Text(0, -20, &#39;$-20$&#39;), Text(0, -10, &#39;$-10$&#39;), Text(0, 10, &#39;$+10$&#39;), Text(0, 20, &#39;$+20$&#39;)]) # Mover los spines ax = plt.gca() # obtener los ejes actuales ax.spines[&#39;right&#39;].set_color(&#39;none&#39;) ax.spines[&#39;top&#39;].set_color(&#39;none&#39;) ax.spines[&#39;bottom&#39;].set_position(&#39;zero&#39;) ax.spines[&#39;left&#39;].set_position(&#39;zero&#39;) # Añadimos títulos al eje X, Y y título del plot plt.xlabel(&#39;Eje X&#39;) plt.ylabel(&#39;Eje Y&#39;) plt.title(&#39;Gráfico de funciones cuadráticas&#39;) # Leyenda para la primera función first_legend = plt.legend(handles=[line1], loc=1) # Añadir la leyenda de la primera función ax = plt.gca().add_artist(first_legend) # Crear la segunda leyenda plt.legend(handles=[line2], loc=4) # Mostramos el plot plt.show() Para ver ayuda sobre como usar las posiciones de las leyendas: #help(plt.legend()) 4.8.1.7 Realizar anotaciones Tipos de flechas y estilos de anotaciones, cheatsheets de matplotlib Tipos de flechas y estilos de anotaciones, cheatsheets de matplotlib # Definimos las funciones para hacer el plot x = np.linspace(-5, 5, 40) fx, gx = x**2, -x**2+5 # Calculamos el punto máximo y mínimo de cada función max_fx, min_fx = x[np.argmax(fx)], x[np.argmin(fx)] max_gx, min_gx = x[np.argmax(gx)], x[np.argmin(gx)] # Cambiamos tamaño de figura plt.figure(figsize=(10,10), dpi=80) # Configuramos color y tipo de línea plt.plot(x, fx, color=&quot;red&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label= &quot;$x^2$&quot;) plt.plot(x, gx, color=&quot;green&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label= &quot;$-x^2 + 5$&quot;) # Configuramos límites de los ejes plt.xlim(-6,6) ## (-6.0, 6.0) plt.ylim(gx.min()*1.1, fx.max()*1.1) ## (-22.0, 27.500000000000004) # Configuración del label de los ticks plt.xticks(np.arange(-2,3,0.5), [r&#39;$-2$&#39;, r&#39;$-\\frac{3}{2}$&#39;, r&#39;$-1$&#39;, r&#39;$-\\frac{1}{2}$&#39;, r&#39;$0$&#39;,r&#39;$\\frac{1}{2}$&#39;, r&#39;$1$&#39;, r&#39;$\\frac{3}{2}$&#39;, r&#39;$2$&#39;, r&#39;$\\frac{5}{2}$&#39;]) ## ([&lt;matplotlib.axis.XTick object at 0x00000250286B7ED0&gt;, &lt;matplotlib.axis.XTick object at 0x000002502874E510&gt;, &lt;matplotlib.axis.XTick object at 0x00000250284C6B90&gt;, &lt;matplotlib.axis.XTick object at 0x00000250286633D0&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028496AD0&gt;, &lt;matplotlib.axis.XTick object at 0x00000250234CAE90&gt;, &lt;matplotlib.axis.XTick object at 0x0000025029FB9BD0&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028743A10&gt;, &lt;matplotlib.axis.XTick object at 0x00000250286D4710&gt;, &lt;matplotlib.axis.XTick object at 0x00000250286FFA90&gt;], [Text(-2.0, 0, &#39;$-2$&#39;), Text(-1.5, 0, &#39;$-\\\\frac{3}{2}$&#39;), Text(-1.0, 0, &#39;$-1$&#39;), Text(-0.5, 0, &#39;$-\\\\frac{1}{2}$&#39;), Text(0.0, 0, &#39;$0$&#39;), Text(0.5, 0, &#39;$\\\\frac{1}{2}$&#39;), Text(1.0, 0, &#39;$1$&#39;), Text(1.5, 0, &#39;$\\\\frac{3}{2}$&#39;), Text(2.0, 0, &#39;$2$&#39;), Text(2.5, 0, &#39;$\\\\frac{5}{2}$&#39;)]) plt.yticks([-20,-10,10,20],[r&#39;$-20$&#39;, r&#39;$-10$&#39;, r&#39;$+10$&#39;, r&#39;$+20$&#39;]) ## ([&lt;matplotlib.axis.YTick object at 0x0000025028493490&gt;, &lt;matplotlib.axis.YTick object at 0x00000250234D76D0&gt;, &lt;matplotlib.axis.YTick object at 0x00000250250735D0&gt;, &lt;matplotlib.axis.YTick object at 0x00000250284C9190&gt;], [Text(0, -20, &#39;$-20$&#39;), Text(0, -10, &#39;$-10$&#39;), Text(0, 10, &#39;$+10$&#39;), Text(0, 20, &#39;$+20$&#39;)]) # Mover los spines ax = plt.gca() # obtener los ejes actuales ax.spines[&#39;right&#39;].set_color(&#39;none&#39;) ax.spines[&#39;top&#39;].set_color(&#39;none&#39;) ax.spines[&#39;bottom&#39;].set_position(&#39;zero&#39;) ax.spines[&#39;left&#39;].set_position(&#39;zero&#39;) # Añadimos títulos al eje X, Y y título del plot plt.xlabel(&#39;Eje X&#39;) plt.ylabel(&#39;Eje Y&#39;) plt.title(&#39;Gráfico de funciones cuadráticas&#39;) # Marcamos los puntos máximos y mínimos con anotaciones plt.annotate(&#39;Min $(%.1f, %.1f)$&#39; % (min_fx, min(fx)), xy=(min_fx, min(fx)), xycoords=&#39;data&#39;, xytext=(-120, -40), textcoords=&#39;offset points&#39;, fontsize=12, arrowprops=dict(arrowstyle=&quot;-&gt;&quot;, connectionstyle=&quot;arc3,rad=.2&quot;)) plt.annotate(&#39;Máx $(%.1f, %.1f)$&#39; % (max_gx, max(gx)), xy=(max_gx, max(gx)), xycoords=&#39;data&#39;, xytext=(+10, +30), textcoords=&#39;offset points&#39;, fontsize=12, arrowprops=dict(arrowstyle=&quot;-&gt;&quot;, connectionstyle=&quot;arc3,rad=.2&quot;)) # Configurar posición de la leyenda plt.legend(loc = &#39;center left&#39;) # Mostramos el plot plt.show() Vamos a desglosar la función plt.annotate() y sus argumentos: 'Min $(%.1f, %.1f)$' % (min_fx, min(fx)): Esta parte crea el texto que se mostrará como la anotación. El % se utiliza para formatear la cadena con los valores de min_fx y min(fx), que son las coordenadas del punto mínimo en el eje x y y respectivamente. El .1f asegura que solo se muestre un decimal en el texto. xy=(min_fx, min(fx)): Establece las coordenadas del punto donde se colocará la anotación. En este caso, min_fx y min(fx) representan las coordenadas del punto mínimo en el gráfico. xycoords='data': Especifica el sistema de coordenadas utilizado para las coordenadas xy. En este caso, se refiere al sistema de coordenadas de los datos. xytext=(-50, -30): Especifica las coordenadas del texto de la anotación. En este caso, se desplaza el texto 50 puntos hacia la izquierda y 30 puntos hacia abajo desde la posición del punto. textcoords='offset points': Indica el sistema de coordenadas utilizado para las coordenadas xytext. En este caso, se utiliza un sistema de coordenadas desplazado desde el punto de datos. fontsize=12: Establece el tamaño de fuente del texto de la anotación. arrowprops=dict(arrowstyle=\"-&gt;\", connectionstyle=\"arc3,rad=.2\"): Define las propiedades de la flecha que se utilizará para señalar el punto de la anotación. En este caso, la flecha tendrá un estilo de punta de flecha (arrowstyle=\"-&gt;\") y una conexión curva (connectionstyle=\"arc3,rad=.2\"). La conexión curva se especifica con un radio de curvatura de 0.2 (rad=.2). 4.8.1.8 Más detalles # Definimos las funciones para hacer el plot x = np.linspace(-5, 5, 40) fx, gx = x**2, -x**2+5 # Calculamos el punto máximo y mínimo de cada función max_fx, min_fx = x[np.argmax(fx)], x[np.argmin(fx)] max_gx, min_gx = x[np.argmax(gx)], x[np.argmin(gx)] # Cambiamos tamaño de figura plt.figure(figsize=(10,10), dpi=80) # Configuramos color y tipo de línea plt.plot(x, fx, color=&quot;red&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label= &quot;$x^2$&quot;) plt.plot(x, gx, color=&quot;green&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label= &quot;$-x^2 + 5$&quot;) # Configuramos límites de los ejes con cero centrado plt.xlim(-5, 5) ## (-5.0, 5.0) plt.ylim(-20, 20) ## (-20.0, 20.0) # Configuración del label de los ticks plt.xticks(np.arange(-2,3,0.5), [r&#39;$-2$&#39;, r&#39;$-\\frac{3}{2}$&#39;, r&#39;$-1$&#39;, r&#39;$-\\frac{1}{2}$&#39;, r&#39;$0$&#39;,r&#39;$\\frac{1}{2}$&#39;, r&#39;$1$&#39;, r&#39;$\\frac{3}{2}$&#39;, r&#39;$2$&#39;, r&#39;$\\frac{5}{2}$&#39;]) ## ([&lt;matplotlib.axis.XTick object at 0x0000025028726790&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028661110&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028E65E90&gt;, &lt;matplotlib.axis.XTick object at 0x00000250287D65D0&gt;, &lt;matplotlib.axis.XTick object at 0x00000250287F2250&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028822C90&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028EA2AD0&gt;, &lt;matplotlib.axis.XTick object at 0x000002502878D850&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028820D10&gt;, &lt;matplotlib.axis.XTick object at 0x00000250286D6750&gt;], [Text(-2.0, 0, &#39;$-2$&#39;), Text(-1.5, 0, &#39;$-\\\\frac{3}{2}$&#39;), Text(-1.0, 0, &#39;$-1$&#39;), Text(-0.5, 0, &#39;$-\\\\frac{1}{2}$&#39;), Text(0.0, 0, &#39;$0$&#39;), Text(0.5, 0, &#39;$\\\\frac{1}{2}$&#39;), Text(1.0, 0, &#39;$1$&#39;), Text(1.5, 0, &#39;$\\\\frac{3}{2}$&#39;), Text(2.0, 0, &#39;$2$&#39;), Text(2.5, 0, &#39;$\\\\frac{5}{2}$&#39;)]) plt.yticks([-20,-10,10,20],[r&#39;$-20$&#39;, r&#39;$-10$&#39;, r&#39;$+10$&#39;, r&#39;$+20$&#39;]) ## ([&lt;matplotlib.axis.YTick object at 0x0000025029FB8CD0&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028408310&gt;, &lt;matplotlib.axis.YTick object at 0x00000250284DCB50&gt;, &lt;matplotlib.axis.YTick object at 0x0000025029FAFB90&gt;], [Text(0, -20, &#39;$-20$&#39;), Text(0, -10, &#39;$-10$&#39;), Text(0, 10, &#39;$+10$&#39;), Text(0, 20, &#39;$+20$&#39;)]) # Mover los spines ax = plt.gca() # obtener los ejes actuales ax.spines[&#39;right&#39;].set_color(&#39;none&#39;) ax.spines[&#39;top&#39;].set_color(&#39;none&#39;) ax.spines[&#39;bottom&#39;].set_position(&#39;zero&#39;) ax.spines[&#39;left&#39;].set_position(&#39;zero&#39;) # Añadimos títulos al eje X, Y y título del plot plt.xlabel(&#39;Eje X&#39;) plt.ylabel(&#39;Eje Y&#39;) plt.title(&#39;Gráfico de funciones cuadráticas&#39;) # Marcamos los puntos máximos y mínimos con anotaciones plt.annotate(&#39;Min $(%.1f, %.1f)$&#39; % (min_fx, min(fx)), xy=(min_fx, min(fx)), xycoords=&#39;data&#39;, xytext=(-120, -40), textcoords=&#39;offset points&#39;, fontsize=12, arrowprops=dict(arrowstyle=&quot;-&gt;&quot;, connectionstyle=&quot;arc3,rad=.2&quot;)) plt.annotate(&#39;Máx $(%.1f, %.1f)$&#39; % (max_gx, max(gx)), xy=(max_gx, max(gx)), xycoords=&#39;data&#39;, xytext=(+10, +30), textcoords=&#39;offset points&#39;, fontsize=12, arrowprops=dict(arrowstyle=&quot;-&gt;&quot;, connectionstyle=&quot;arc3,rad=.2&quot;)) for label in ax.get_xticklabels() + ax.get_yticklabels(): label.set_fontsize(14) label.set_bbox(dict(facecolor=&#39;white&#39;, edgecolor=&#39;None&#39;, alpha=0.65)) # Configurar posición de la leyenda plt.legend(loc = &#39;center left&#39;) # Mostramos el plot plt.show() 4.8.1.9 Subplots Como vimos, una Figura en matplotlib es toda la ventana, toda la interface. Podemos crear varios subplots en una figura y configurar cada uno de ellos. fig = plt.figure() # Una figura vacía fig, ax = plt.subplots() # una figura con solo un axes fig, axs = plt.subplots(2, 2) # un grid de figuras 2x2 # una figura con un subplot a la izquierda y dos a la derecha fig, axs = plt.subplot_mosaic([[&#39;left&#39;, &#39;right_top&#39;], [&#39;left&#39;, &#39;right_bottom&#39;]]) Con el ejemplo de las funciones que hemos estado trabajando, podríamos separarlas en dos subplots como sigue. # Definimos las funciones para hacer el plot x = np.linspace(-5, 5, 40) fx, gx = x**2, -x**2 + 5 # Calculamos el punto máximo y mínimo de cada función max_fx, min_fx = x[np.argmax(fx)], x[np.argmin(fx)] max_gx, min_gx = x[np.argmax(gx)], x[np.argmin(gx)] # Configuramos tamaño de figura y creamos subplots plt.figure(figsize=(10, 10)) # Subplot para la función fx = x^2 plt.subplot(2, 1, 1) plt.plot(x, fx, color=&quot;red&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label=&quot;$x^2$&quot;) plt.xlim(-6, 6) ## (-6.0, 6.0) plt.ylim(fx.min() * 1.1, fx.max() * 1.1) ## (0.018080210387902567, 27.500000000000004) plt.xticks(np.arange(-2, 3, 0.5), [r&#39;$-2$&#39;, r&#39;$-\\frac{3}{2}$&#39;, r&#39;$-1$&#39;, r&#39;$-\\frac{1}{2}$&#39;, r&#39;$0$&#39;, r&#39;$\\frac{1}{2}$&#39;, r&#39;$1$&#39;, r&#39;$\\frac{3}{2}$&#39;, r&#39;$2$&#39;, r&#39;$\\frac{5}{2}$&#39;]) ## ([&lt;matplotlib.axis.XTick object at 0x00000250284A4650&gt;, &lt;matplotlib.axis.XTick object at 0x000002502503EDD0&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028B04BD0&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028DB7450&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028E26690&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028E68710&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028E6A710&gt;, &lt;matplotlib.axis.XTick object at 0x00000250286CC610&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028E25610&gt;, &lt;matplotlib.axis.XTick object at 0x00000250286CEA50&gt;], [Text(-2.0, 0, &#39;$-2$&#39;), Text(-1.5, 0, &#39;$-\\\\frac{3}{2}$&#39;), Text(-1.0, 0, &#39;$-1$&#39;), Text(-0.5, 0, &#39;$-\\\\frac{1}{2}$&#39;), Text(0.0, 0, &#39;$0$&#39;), Text(0.5, 0, &#39;$\\\\frac{1}{2}$&#39;), Text(1.0, 0, &#39;$1$&#39;), Text(1.5, 0, &#39;$\\\\frac{3}{2}$&#39;), Text(2.0, 0, &#39;$2$&#39;), Text(2.5, 0, &#39;$\\\\frac{5}{2}$&#39;)]) plt.yticks([-20, -10, 10, 20], [r&#39;$-20$&#39;, r&#39;$-10$&#39;, r&#39;$+10$&#39;, r&#39;$+20$&#39;]) ## ([&lt;matplotlib.axis.YTick object at 0x0000025028754E10&gt;, &lt;matplotlib.axis.YTick object at 0x00000250287F1110&gt;, &lt;matplotlib.axis.YTick object at 0x00000250284AE490&gt;, &lt;matplotlib.axis.YTick object at 0x000002502871F1D0&gt;], [Text(0, -20, &#39;$-20$&#39;), Text(0, -10, &#39;$-10$&#39;), Text(0, 10, &#39;$+10$&#39;), Text(0, 20, &#39;$+20$&#39;)]) plt.xlabel(&#39;Eje X&#39;) plt.ylabel(&#39;Eje Y&#39;) plt.title(&#39;Función $x^2$&#39;) plt.annotate(&#39;Min $(%.1f, %.1f)$&#39; % (min_fx, min(fx)), xy=(min_fx, min(fx)), xycoords=&#39;data&#39;, xytext=(-120, -40), textcoords=&#39;offset points&#39;, fontsize=12, arrowprops=dict(arrowstyle=&quot;-&gt;&quot;, connectionstyle=&quot;arc3,rad=.2&quot;)) plt.legend(loc=&#39;upper left&#39;) # Subplot para la función gx = -x^2 + 5 plt.subplot(2, 1, 2) plt.plot(x, gx, color=&quot;green&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label=&quot;$-x^2 + 5$&quot;) plt.xlim(-6, 6) ## (-6.0, 6.0) plt.ylim(gx.min() * 1.1, gx.max() * 1.1) ## (-22.0, 5.481919789612098) plt.xticks(np.arange(-2, 3, 0.5), [r&#39;$-2$&#39;, r&#39;$-\\frac{3}{2}$&#39;, r&#39;$-1$&#39;, r&#39;$-\\frac{1}{2}$&#39;, r&#39;$0$&#39;, r&#39;$\\frac{1}{2}$&#39;, r&#39;$1$&#39;, r&#39;$\\frac{3}{2}$&#39;, r&#39;$2$&#39;, r&#39;$\\frac{5}{2}$&#39;]) ## ([&lt;matplotlib.axis.XTick object at 0x0000025028E6A490&gt;, &lt;matplotlib.axis.XTick object at 0x0000025028DB5390&gt;, &lt;matplotlib.axis.XTick object at 0x00000250287B14D0&gt;, &lt;matplotlib.axis.XTick object at 0x000002502A020A90&gt;, &lt;matplotlib.axis.XTick object at 0x000002502A017590&gt;, &lt;matplotlib.axis.XTick object at 0x0000025029FE1590&gt;, &lt;matplotlib.axis.XTick object at 0x0000025029FE3490&gt;, &lt;matplotlib.axis.XTick object at 0x000002502A0170D0&gt;, &lt;matplotlib.axis.XTick object at 0x000002502A005D10&gt;, &lt;matplotlib.axis.XTick object at 0x000002502A007C50&gt;], [Text(-2.0, 0, &#39;$-2$&#39;), Text(-1.5, 0, &#39;$-\\\\frac{3}{2}$&#39;), Text(-1.0, 0, &#39;$-1$&#39;), Text(-0.5, 0, &#39;$-\\\\frac{1}{2}$&#39;), Text(0.0, 0, &#39;$0$&#39;), Text(0.5, 0, &#39;$\\\\frac{1}{2}$&#39;), Text(1.0, 0, &#39;$1$&#39;), Text(1.5, 0, &#39;$\\\\frac{3}{2}$&#39;), Text(2.0, 0, &#39;$2$&#39;), Text(2.5, 0, &#39;$\\\\frac{5}{2}$&#39;)]) plt.yticks([-20, -10, 10, 20], [r&#39;$-20$&#39;, r&#39;$-10$&#39;, r&#39;$+10$&#39;, r&#39;$+20$&#39;]) ## ([&lt;matplotlib.axis.YTick object at 0x0000025028DB6E10&gt;, &lt;matplotlib.axis.YTick object at 0x0000025028E24790&gt;, &lt;matplotlib.axis.YTick object at 0x000002502849B850&gt;, &lt;matplotlib.axis.YTick object at 0x000002502503E250&gt;], [Text(0, -20, &#39;$-20$&#39;), Text(0, -10, &#39;$-10$&#39;), Text(0, 10, &#39;$+10$&#39;), Text(0, 20, &#39;$+20$&#39;)]) plt.xlabel(&#39;Eje X&#39;) plt.ylabel(&#39;Eje Y&#39;) plt.title(&#39;Función $-x^2 + 5$&#39;) plt.annotate(&#39;Máx $(%.1f, %.1f)$&#39; % (max_gx, max(gx)), xy=(max_gx, max(gx)), xycoords=&#39;data&#39;, xytext=(+10, +30), textcoords=&#39;offset points&#39;, fontsize=12, arrowprops=dict(arrowstyle=&quot;-&gt;&quot;, connectionstyle=&quot;arc3,rad=.2&quot;)) plt.legend(loc=&#39;upper left&#39;) # Mostramos el plot plt.tight_layout() plt.show() Con el método OO: # Definimos las funciones para hacer el plot x = np.linspace(-5, 5, 40) fx, gx = x**2, -x**2 + 5 # Calculamos el punto máximo y mínimo de cada función max_fx, min_fx = x[np.argmax(fx)], x[np.argmin(fx)] max_gx, min_gx = x[np.argmax(gx)], x[np.argmin(gx)] # Cambiamos tamaño de figura fig, axs = plt.subplots(2, 1, figsize=(10, 10)) # Configuramos color y tipo de línea para la primera función axs[0].plot(x, fx, color=&quot;red&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label=&quot;$x^2$&quot;) axs[0].set_xlim(-6, 6) ## (-6.0, 6.0) axs[0].set_ylim(fx.min() * 1.1, fx.max() * 1.1) ## (0.018080210387902567, 27.500000000000004) axs[0].set_xticks(np.arange(-2, 3, 0.5)) axs[0].set_yticks([-20, -10, 10, 20]) axs[0].set_xlabel(&#39;Eje X&#39;) axs[0].set_ylabel(&#39;Eje Y&#39;) axs[0].set_title(&#39;Función $x^2$&#39;) # Anotaciones en el subplot de la primera función axs[0].annotate(&#39;Min $(%.1f, %.1f)$&#39; % (min_fx, min(fx)), xy=(min_fx, min(fx)), xycoords=&#39;data&#39;, xytext=(-120, -40), textcoords=&#39;offset points&#39;, fontsize=12, arrowprops=dict(arrowstyle=&quot;-&gt;&quot;, connectionstyle=&quot;arc3,rad=.2&quot;)) # Configurar posición de la leyenda en el subplot de la primera función axs[0].legend(loc=&#39;upper left&#39;) # Configuramos color y tipo de línea para la segunda función axs[1].plot(x, gx, color=&quot;green&quot;, linewidth=2.5, linestyle=&quot;-&quot;, label=&quot;$-x^2 + 5$&quot;) axs[1].set_xlim(-6, 6) ## (-6.0, 6.0) axs[1].set_ylim(gx.min() * 1.1, gx.max() * 1.1) ## (-22.0, 5.481919789612098) axs[1].set_xticks(np.arange(-2, 3, 0.5)) axs[1].set_yticks([-20, -10, 10, 20]) axs[1].set_xticklabels([r&#39;$-2$&#39;, r&#39;$-\\frac{3}{2}$&#39;, r&#39;$-1$&#39;, r&#39;$-\\frac{1}{2}$&#39;, r&#39;$0$&#39;, r&#39;$\\frac{1}{2}$&#39;, r&#39;$1$&#39;, r&#39;$\\frac{3}{2}$&#39;, r&#39;$2$&#39;, r&#39;$\\frac{5}{2}$&#39;]) axs[1].set_yticklabels([r&#39;$-20$&#39;, r&#39;$-10$&#39;, r&#39;$+10$&#39;, r&#39;$+20$&#39;]) axs[1].set_xlabel(&#39;Eje X&#39;) axs[1].set_ylabel(&#39;Eje Y&#39;) axs[1].set_title(&#39;Función $-x^2 + 5$&#39;) # Anotaciones en el subplot de la segunda función axs[1].annotate(&#39;Máx $(%.1f, %.1f)$&#39; % (max_gx, max(gx)), xy=(max_gx, max(gx)), xycoords=&#39;data&#39;, xytext=(+10, +30), textcoords=&#39;offset points&#39;, fontsize=12, arrowprops=dict(arrowstyle=&quot;-&gt;&quot;, connectionstyle=&quot;arc3,rad=.2&quot;)) # Configurar posición de la leyenda en el subplot de la segunda función axs[1].legend(loc=&#39;upper left&#39;) # Mostramos el plot plt.tight_layout() plt.show() 4.8.1.10 Paletas de colores Existen varias paletas de colores que podemos usar. from matplotlib import colormaps list(colormaps) ## [&#39;magma&#39;, &#39;inferno&#39;, &#39;plasma&#39;, &#39;viridis&#39;, &#39;cividis&#39;, &#39;twilight&#39;, &#39;twilight_shifted&#39;, &#39;turbo&#39;, &#39;Blues&#39;, &#39;BrBG&#39;, &#39;BuGn&#39;, &#39;BuPu&#39;, &#39;CMRmap&#39;, &#39;GnBu&#39;, &#39;Greens&#39;, &#39;Greys&#39;, &#39;OrRd&#39;, &#39;Oranges&#39;, &#39;PRGn&#39;, &#39;PiYG&#39;, &#39;PuBu&#39;, &#39;PuBuGn&#39;, &#39;PuOr&#39;, &#39;PuRd&#39;, &#39;Purples&#39;, &#39;RdBu&#39;, &#39;RdGy&#39;, &#39;RdPu&#39;, &#39;RdYlBu&#39;, &#39;RdYlGn&#39;, &#39;Reds&#39;, &#39;Spectral&#39;, &#39;Wistia&#39;, &#39;YlGn&#39;, &#39;YlGnBu&#39;, &#39;YlOrBr&#39;, &#39;YlOrRd&#39;, &#39;afmhot&#39;, &#39;autumn&#39;, &#39;binary&#39;, &#39;bone&#39;, &#39;brg&#39;, &#39;bwr&#39;, &#39;cool&#39;, &#39;coolwarm&#39;, &#39;copper&#39;, &#39;cubehelix&#39;, &#39;flag&#39;, &#39;gist_earth&#39;, &#39;gist_gray&#39;, &#39;gist_heat&#39;, &#39;gist_ncar&#39;, &#39;gist_rainbow&#39;, &#39;gist_stern&#39;, &#39;gist_yarg&#39;, &#39;gnuplot&#39;, &#39;gnuplot2&#39;, &#39;gray&#39;, &#39;hot&#39;, &#39;hsv&#39;, &#39;jet&#39;, &#39;nipy_spectral&#39;, &#39;ocean&#39;, &#39;pink&#39;, &#39;prism&#39;, &#39;rainbow&#39;, &#39;seismic&#39;, &#39;spring&#39;, &#39;summer&#39;, &#39;terrain&#39;, &#39;winter&#39;, &#39;Accent&#39;, &#39;Dark2&#39;, &#39;Paired&#39;, &#39;Pastel1&#39;, &#39;Pastel2&#39;, &#39;Set1&#39;, &#39;Set2&#39;, &#39;Set3&#39;, &#39;tab10&#39;, &#39;tab20&#39;, &#39;tab20b&#39;, &#39;tab20c&#39;, &#39;magma_r&#39;, &#39;inferno_r&#39;, &#39;plasma_r&#39;, &#39;viridis_r&#39;, &#39;cividis_r&#39;, &#39;twilight_r&#39;, &#39;twilight_shifted_r&#39;, &#39;turbo_r&#39;, &#39;Blues_r&#39;, &#39;BrBG_r&#39;, &#39;BuGn_r&#39;, &#39;BuPu_r&#39;, &#39;CMRmap_r&#39;, &#39;GnBu_r&#39;, &#39;Greens_r&#39;, &#39;Greys_r&#39;, &#39;OrRd_r&#39;, &#39;Oranges_r&#39;, &#39;PRGn_r&#39;, &#39;PiYG_r&#39;, &#39;PuBu_r&#39;, &#39;PuBuGn_r&#39;, &#39;PuOr_r&#39;, &#39;PuRd_r&#39;, &#39;Purples_r&#39;, &#39;RdBu_r&#39;, &#39;RdGy_r&#39;, &#39;RdPu_r&#39;, &#39;RdYlBu_r&#39;, &#39;RdYlGn_r&#39;, &#39;Reds_r&#39;, &#39;Spectral_r&#39;, &#39;Wistia_r&#39;, &#39;YlGn_r&#39;, &#39;YlGnBu_r&#39;, &#39;YlOrBr_r&#39;, &#39;YlOrRd_r&#39;, &#39;afmhot_r&#39;, &#39;autumn_r&#39;, &#39;binary_r&#39;, &#39;bone_r&#39;, &#39;brg_r&#39;, &#39;bwr_r&#39;, &#39;cool_r&#39;, &#39;coolwarm_r&#39;, &#39;copper_r&#39;, &#39;cubehelix_r&#39;, &#39;flag_r&#39;, &#39;gist_earth_r&#39;, &#39;gist_gray_r&#39;, &#39;gist_heat_r&#39;, &#39;gist_ncar_r&#39;, &#39;gist_rainbow_r&#39;, &#39;gist_stern_r&#39;, &#39;gist_yarg_r&#39;, &#39;gnuplot_r&#39;, &#39;gnuplot2_r&#39;, &#39;gray_r&#39;, &#39;hot_r&#39;, &#39;hsv_r&#39;, &#39;jet_r&#39;, &#39;nipy_spectral_r&#39;, &#39;ocean_r&#39;, &#39;pink_r&#39;, &#39;prism_r&#39;, &#39;rainbow_r&#39;, &#39;seismic_r&#39;, &#39;spring_r&#39;, &#39;summer_r&#39;, &#39;terrain_r&#39;, &#39;winter_r&#39;, &#39;Accent_r&#39;, &#39;Dark2_r&#39;, &#39;Paired_r&#39;, &#39;Pastel1_r&#39;, &#39;Pastel2_r&#39;, &#39;Set1_r&#39;, &#39;Set2_r&#39;, &#39;Set3_r&#39;, &#39;tab10_r&#39;, &#39;tab20_r&#39;, &#39;tab20b_r&#39;, &#39;tab20c_r&#39;] Los colores los podemos indicar en diferentes formatos: RGB o RGBA: (0.1, 0.2, 0.5), (0.1, 0.2, 0.5, 0.3) Cadena de RGB o RGBA: '#0f0f0f', '#0f0f0f80' Hex RGB o RGBA: '#abc' = 'aabbcc', '#fb1' = '#ffbb11' Escala de grises en escala de [0,1]: '0' (negro), '1' (blanco), '0.8' (gris claro) Abreviación de colores básicos: ‘b’ = blue ‘g’ = green ‘r’ = red ‘c’ = cyan ‘m’ = magenta ‘y’ = yellow ‘k’ = black ‘w’ = white Nombre del color: 'aquamarine', 'mediumseagreen' Del ciclo de colores default: C0, C1, donde el ciclo es ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'] Tupla de color y valor de transparencia alfa: ('green',0.3) A los colores les podemos indicar también un nivel de transparencia que se llama alpha: ## (-0.2, 13.0) ## (-1.0, 1.0) ## (-0.2, 13.0, -1.0, 1.0) 4.8.1.11 Orden de los elementos El orden de dibujo de los artistas en Matplotlib está determinado por su atributo zorder, que es un número decimal flotante. Los artistas con un zorder más alto se dibujan encima de los artistas con un zorder más bajo. Esto es útil cuando se tienen múltiples elementos en un gráfico y se desea controlar qué elementos están encima de otros. Por defecto, Matplotlib asigna un valor de zorder dependiendo del tipo de artista. Los artistas más comunes, como las líneas, los puntos y los contornos, suelen tener un valor de zorder predeterminado más alto para que se dibujen encima de otros elementos. Por ejemplo, si se tiene una línea y un marcador en un gráfico, la línea se dibujará encima del marcador si tienen el mismo color y estilo. Sin embargo, si se desea que el marcador se dibuje encima de la línea, se puede ajustar el zorder del marcador para que sea mayor que el de la línea. Z-order, del manual de matplotlib r = np.linspace(0.3, 1, 30) theta = np.linspace(0, 4*np.pi, 30) x = r * np.sin(theta) y = r * np.cos(theta) plt.figure(figsize=(10, 5)) plt.subplot(1, 2, 1) plt.plot(x, y, &#39;C3&#39;, lw=3) plt.scatter(x, y, s=120) plt.title(&#39;Líneas sobre los puntos&#39;) plt.subplot(1, 2, 2) plt.plot(x, y, &#39;C3&#39;, lw=3) plt.scatter(x, y, s=120, zorder=2.5) # mover los puntos encima de la línea plt.title(&#39;Puntos sobre las líneas&#39;) plt.tight_layout() plt.show() 4.8.2 Tipos de plots 4.8.2.1 Áreas entre curvas La función fill_between() en Matplotlib se utiliza para crear áreas sombreadas entre dos curvas o entre una curva y un eje. Esto puede ser útil para resaltar ciertas regiones en un gráfico. # Definimos los datos x = np.linspace(0, 10, 100) y1 = np.sin(x) y2 = np.cos(x) # Creamos el gráfico plt.figure(figsize=(8, 6)) # Graficamos las curvas plt.plot(x, y1, color=&quot;#a1dab4&quot;, label=&#39;sin(x)&#39;) plt.plot(x, y2, color=&quot;#253494&quot;, label=&#39;cos(x)&#39;) # Rellenamos el área entre las curvas y=sen(x) y y=cos(x) plt.fill_between(x, y1, y2, where=(y1 &gt;= y2), color=(0.1, 0.2, 0.5), alpha=0.3, interpolate=True, label=&#39;Área entre curvas&#39;) # Añadimos etiquetas y título plt.xlabel(&#39;x&#39;) plt.ylabel(&#39;y&#39;) plt.title(&#39;Área sombreada entre curvas&#39;) # Mover la leyenda fuera del gráfico plt.legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1, 1)) # Mostramos el gráfico plt.grid(True) plt.show() El parámetro interpolate en la función fill_between() de Matplotlib controla si se debe interpolar entre los puntos de datos al rellenar el área entre las curvas. Cuando interpolate está establecido en True, Matplotlib interpolará suavemente entre los puntos de datos para crear un área sombreada más suave entre las curvas. Esto puede ser útil cuando los datos están espaciados de manera irregular o cuando se desea una representación visualmente más atractiva del área sombreada. 4.8.2.2 Scatter plot o gráfico de dispersión # Definimos los datos np.random.seed(0) n = 100 x = np.random.rand(n) y = np.random.rand(n) colors = np.arctan2(y, x) # Calculamos el ángulo para determinar el color sizes = 1000 * np.random.rand(n) # Tamaño de los marcadores # Creamos el gráfico plt.figure(figsize=(8, 6)) # Graficamos los marcadores plt.scatter(x, y, c=colors, s=sizes, alpha=0.5, cmap=&#39;hsv&#39;) # Añadimos etiquetas y título plt.xlabel(&#39;X&#39;) plt.ylabel(&#39;Y&#39;) plt.title(&#39;Gráfico de marcadores con color según el ángulo&#39;) # Mostramos la barra de color plt.colorbar(label=&#39;Ángulo&#39;) ## &lt;matplotlib.colorbar.Colorbar object at 0x000002502B133A90&gt; # Mostramos el gráfico plt.grid(True) plt.show() Ejercicio 1: Usando seaborn, carga la base de datos iris y crea un gráfico de dispersión de la longitud del sepalo vs la anchura del sepalo. import seaborn as sns # Cargar el conjunto de datos de iris iris = sns.load_dataset(&#39;iris&#39;) Ejercicio 2: Usando la base de datos penguins de seaborn crea el siguiente gráfico de dispersión. 4.8.2.3 Gráfico de barras # Datos categories = [&#39;0-20&#39;, &#39;21-40&#39;, &#39;41-60&#39;, &#39;61-80&#39;, &#39;81+&#39;] women_counts = [50, 120, 80, 30, 10] men_counts = [40, 100, 70, 25, 5] color_above = &#39;lightcoral&#39; color_below = &#39;lightblue&#39; offset = 5 # Offset para las barras arriba del eje x # Creamos el gráfico de barras plt.figure(figsize=(10, 6)) # Barras superiores (mujeres) plt.bar(categories, women_counts, color=color_above, label=&#39;Mujeres&#39;) # Barras inferiores (hombres) plt.bar(categories, [-count for count in men_counts], color=color_below, label=&#39;Hombres&#39;) # Añadimos etiquetas y título plt.xlabel(&#39;Rango de Edad&#39;) plt.ylabel(&#39;Cantidad&#39;) plt.title(&#39;Cantidad de Mujeres y Hombres por Rango de Edad en un Centro de Convenciones&#39;) # Añadimos la leyenda plt.legend() # Mostramos el gráfico plt.grid(True) plt.show() Ejercicio: Usando la base de datos penguins de seaborn, crea un gráfico de barras que muestre la cantidad promedio de pingüinos de cada especie en la base de datos. 4.8.2.4 Gráfico de pastel # Datos edades = [&#39;0-20 años&#39;, &#39;21-40 años&#39;, &#39;41-60 años&#39;, &#39;61-80 años&#39;, &#39;81+ años&#39;] cantidad_personas = [25, 50, 40, 20, 5] # Número de personas en cada grupo de edad # Colores para cada categoría de edad colors = [&#39;lightblue&#39;, &#39;lightgreen&#39;, &#39;lightcoral&#39;, &#39;lightyellow&#39;, &#39;lightpink&#39;] # Creamos el pie chart plt.figure(figsize=(8, 8)) plt.pie(cantidad_personas, labels=edades, autopct=&#39;%1.1f%%&#39;, startangle=140, colors=colors) ## ([&lt;matplotlib.patches.Wedge object at 0x000002502BBCC650&gt;, &lt;matplotlib.patches.Wedge object at 0x000002502BBFDC10&gt;, &lt;matplotlib.patches.Wedge object at 0x0000025029947590&gt;, &lt;matplotlib.patches.Wedge object at 0x0000025029946C50&gt;, &lt;matplotlib.patches.Wedge object at 0x000002502995B1D0&gt;], [Text(-1.0896731958656476, 0.1503739545664288, &#39;0-20 años&#39;), Text(-0.027423702079068427, -1.099658101668095, &#39;21-40 años&#39;), Text(1.0026563830822577, 0.452415934140703, &#39;41-60 años&#39;), Text(-0.21796095220362108, 1.078189697277103, &#39;61-80 años&#39;), Text(-0.7581843362242401, 0.7969670710287902, &#39;81+ años&#39;)], [Text(-0.5943671977448985, 0.08202215703623389, &#39;17.9%&#39;), Text(-0.01495838295221914, -0.5998135100007791, &#39;35.7%&#39;), Text(0.5469034816812314, 0.24677232771311072, &#39;28.6%&#39;), Text(-0.11888779211106602, 0.5881034712420561, &#39;14.3%&#39;), Text(-0.41355509248594907, 0.4347093114702491, &#39;3.6%&#39;)]) # Añadimos título plt.title(&#39;Distribución de Grupos de Personas por Edad en una Conferencia&#39;) # Mostramos el gráfico plt.axis(&#39;equal&#39;) # Para asegurar que el gráfico sea un círculo ## (-1.0999983812882443, 1.0999999132932203, -1.0999999321961162, 1.0999989838375972) plt.show() Ejercicio: Usando la base de datos penguins de seaborn, crea un gráfico de pastel que muestre la proporción de cada especie de pingüino en la base de datos. 4.8.2.5 Boxplot # Cargamos los datos Iris iris = sns.load_dataset(&#39;iris&#39;) # Creamos el boxplot plt.figure(figsize=(8, 6)) sns.boxplot(x=&#39;species&#39;, y=&#39;sepal_length&#39;, data=iris) # Añadimos etiquetas y título plt.xlabel(&#39;Especies&#39;) plt.ylabel(&#39;Longitud del Sépalo&#39;) plt.title(&#39;Boxplot de la longitud del Sépalo para cada especie&#39;) # Mostramos el boxplot plt.show() Ejercicio: Usando la base de datos penguins de seaborn, crea un boxplot que compare las longitudes del pico para cada especie de pingüino en la base de datos. 4.8.2.6 Histograma # Cargar el conjunto de datos Iris iris = sns.load_dataset(&#39;iris&#39;) # Especie específica para la que queremos crear el histograma especie = &#39;setosa&#39; # Filtrar los datos para la especie específica datos_especie = iris[iris[&#39;species&#39;] == especie][&#39;sepal_length&#39;] # Crear el histograma plt.figure(figsize=(8, 6)) plt.hist(datos_especie, bins=10, color=&#39;skyblue&#39;, edgecolor=&#39;black&#39;, alpha=0.7) # Añadir etiquetas y título plt.xlabel(&#39;Longitud del Sépalo&#39;) plt.ylabel(&#39;Frecuencia&#39;) plt.title(f&#39;Histograma de Longitud del Sépalo para la Especie {especie.capitalize()}&#39;) # Mostrar el histograma plt.show() Ejercicio: Usando la base de datos penguins de seaborn, crea un histograma que muestre la distribución de las longitudes del pico para todas las especies de pingüinos. 4.8.2.7 Contour plot # Creamos datos para el Contour Plot x = np.linspace(-3, 3, 100) y = np.linspace(-3, 3, 100) X, Y = np.meshgrid(x, y) Z = np.sin(X) * np.cos(Y) # Creamos el Contour Plot plt.figure(figsize=(8, 6)) contour = plt.contour(X, Y, Z, cmap=&#39;viridis&#39;) # Etiquetamos las líneas de contorno plt.clabel(contour, inline=True, fontsize=8) # Añadimos etiquetas y título plt.xlabel(&#39;Eje X&#39;) plt.ylabel(&#39;Eje Y&#39;) plt.title(&#39;Contour Plot de sin(X) * cos(Y) con Etiquetas&#39;) # Mostramos el gráfico plt.grid(True) plt.show() 4.8.2.8 Imshow En Matplotlib, imshow() se utiliza para mostrar una imagen (2D o 3D) representada como una matriz. Toma como entrada una matriz 2D o 3D donde los valores representan intensidades de píxeles o valores de color. # Creamos una matriz de ejemplo data = np.random.rand(10, 10) # Mostramos la matriz como una imagen utilizando imshow plt.imshow(data, cmap=&#39;viridis&#39;) # Añadimos una barra de color para mostrar la correspondencia entre valores y colores plt.colorbar() ## &lt;matplotlib.colorbar.Colorbar object at 0x000002502C6D1DD0&gt; # Añadimos etiquetas y título plt.xlabel(&#39;X&#39;) plt.ylabel(&#39;Y&#39;) plt.title(&#39;Imshow()&#39;) # Mostramos la gráfica plt.show() Se puede ocupar para hacer mapas de calor. Ejercicio: Supongamos que tenemos la siguiente función: \\[ f(x, y) = \\sin(x) \\cdot \\cos(y) \\] Generar una cuadrícula de valores para \\(x\\) y \\(y\\) en el rango de \\([-2\\pi, 2\\pi]\\). Calcular los valores de la función \\(f(x, y)\\) para cada par de puntos \\((x, y)\\). Visualizar la función utilizando imshow para mostrar la función como una imagen y contour para mostrar las curvas de nivel. Tu resultado debe ser similar al siguiente: ## &lt;matplotlib.colorbar.Colorbar object at 0x0000025031826D10&gt; ## &lt;matplotlib.colorbar.Colorbar object at 0x000002503193ED10&gt; 4.9 Data frames con pandas 4.10 Manipulación de bases de datos 4.11 Análisis exploratorio de bases de datos 4.12 Funciones y scripts 4.13 Buenas practicas 4.14 Procesamiento de alto rendimiento 4.15 Programación en paralelo "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
