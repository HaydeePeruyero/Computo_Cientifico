# Git y Github

```{r setup2, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```

```{r, include=FALSE}
workingDir <-  "."
setwd(workingDir)
```

Usar control de versiones es una forma de manejar proyectos, todo a lo que se hace `commit` se pierde, se queda un registro de todos los cambios y siempre es posible regresar a una versión anterior. Nos evitamos estar enviando y enviando correos con versiones finales para después comparar versiones. Se guarda el usuario que hizo el cambio y automáticamente obtenemos una notificación de si intentamos modificar lo mismo que un colaborador para revisar cual cambio guardar.

Pueden pensar en versión de control como una forma de `undo` ilimitado y de trabajar paralelamente con sus colaboradores.

Lo primero que vamos a hacer es configurar `Git` en nuestra computadora.

Vamos a abrir `Git bash` y configurar nuestro usuario y correo con la que vamos a enlazar más adelante Github.

```bash
$ git config --global user.name "Usuario"
$ git config --global user.email "email@domain.com"
```

Ahora, vamos a configurar los saltos de línea para no tener conflicto según el sistema operativo.

```bash
# Mac o Linux
$ git config --global core.autocrlf input
# Windows
$ git config --global core.autocrlf true
```

Para configurar el editor de texto por default:

```bash
$ git config --global core.editor "nano -w"
```

Por default, Git inicializa un repositorio con una rama llamada `master`, a partir del 2020, la mayoría de los servidores de Git cambiaron esto a que la rama principal fuera `main`, para configurar esto usaremos lo siguiente:

```bash
$ git config --global init.defaultBranch main
```

Los comandos anteriores solo se necesitan configurar una sola vez. Para ver la configuración que acabamos de realizar y probar cual es nuestro editor de texto usamos lo siguiente:

```bash
$ git config --global --edit
```

Y para revisar esta configuración sin entrar al editor:

```bash
$ git config --list
```

Si debieran hacer cambios en su usuario o correo o cualquier otra configuración lo pueden hacer ilimitadas veces con los comandos anteriores.

Para pedir ayuda nos sirve aún `git comando -h` o `git comando --help`, por ejemplo:

```bash
$ git config -h
# La siguiente nos abre en un navegador el manual completo
$ git config --help
```

O para ayuda general de Git: `git help`.


## Repositorios

Un repositorio es donde se va a almacenar toda la información de nuestro proyecto, es donde vamos a tener toda la historia y registro de cambios y usuarios. Es recomendable tener un repositorio por proyecto y no multiples proyectos en un solo repositorio. 

Vamos a movernos a la carpeta del curso y vamos a hacer una carpeta para trabajar con git.

```bash
$ cd Curso_Comp_cient
$ mkdir Mi_primer_repo
$ cd Mi_primer_repo
```

Para inicializar un repositorio usamos lo siguiente (dentro de la carperta).

```bash
$ git init
```

Al inicializar el repositorio, cualquier carpeta y archivo que se cree dentro de la carpeta quedará su registro, no es necesario inicializar las carpetas anidadas.

Si revisamos que tiene la carpeta solo con `ls` no vamos a notar ningún cambio pero si listamos con la opción `-a` veremos que contiene archivos ocultos. En el archivo `.git` se almacena **TODA** la información de nuestro repositorio, así que si lo borramos perderemos todo el historial del repositorio.

```bash
$ ls -a
```

Para cambiar manualmente la rama de nuestro repositorio si no es la main, lo podemos hacer como sigue.

```bash
$ git checkout -b main
```

Para preguntarle a git el status de nuestro proyecto:

```bash
$ git status
```

Si dentro de una carpeta preguntamos `git status` y obtenemos el siguiente mensaje:

```output
fatal: not a git repository (or any of the parent directories): .git
```

significa que si podemos inicializarlo como un repositorio.

**Ejercicio:** Dentro de la carpeta `Mi_primer_repo` crea una carpeta llamada `subproyecto1`. Si quieres llevar un registro de lo que hagas en ese subproyecto, ¿debes inicializarla? Inicializala. Ahora, ¿cómo borras el archivo `.git`?


## Rastrear cambios

Vamos a crear un archivo de texto dentro de la carpeta `Mi_primer_repo`.

```bash
$ nano prueba.txt
```

Y escribamos algo en el archivo y guardemoslo.

```bash
Primer archivo en el que rastrearemos cambios.
```

Ahora, si preguntamos por el status de nuestro proyecto vamos a obtener un mensaje de que hay algo nuevo:

```bash
$ git status
```

El mensaje que dice `untracked files` nos indica que hay cambios y que a Git no se le ha idicado que debe registrarlos. Para añadir estos cambios hacemos lo siguiente:

```bash
$ git add prueba.txt
```

Si revisamos el status del proyecto vemos que ahora un mensaje diferente, ahora solo nos indica que no se ha realizado ningún commit pero que si se tiene registro de algo que cambio.

```bash
$ git status
```

Para hacer un commit:

```bash
$ git commit -m "Comenzando archivo de prueba y registro de cambios"
```

Este comando le dice a Git que tome todo lo que se añadió y que guarde una copia permanente dentro del directorio `.git`. Cada commit tiene un identificador único. Si no especificamos el mensaje, Git abrirá un editor de texto para colocar el mensaje. Los mensajes deben de reflejar lo que se está guardando para que sean útiles en el futuro.

Si ahora verificamos el status del proyecto veremos que nos dice que no hay nada a lo que hacer commit ya que en el paso anterior añadimos todo y no hemos realizado ningún cambio.

```bash
$ git status
```

Para mostrar el historial del proyecto:

```bash
$ git log
```

Ahora, añadamos una línea nueva al archivo `prueba.txt`

```bash
$ nano prueba.txt
```

```output
Primer archivo en el que rastrearemos cambios.
Segunda línea de cambios para continuar con el ejemplo.
```

Si revisamos el status veremos de nuevo que nos devuelve el mensaje de que hay archivos sin rastrear. Para comparar las diferencias del archivo usamos:

```bash
$ git diff
```

El signo `+` nos está indicando cuales son los cambios en el archivo nuevo.

Vamos a hacer un commit de este cambio.

```bash
$ git commit -m "Añadimos la segunda linea al archivo"
```

¿Qué paso? Nos esta diciendo que no hemos añadido nada al `staged area` a lo que le podamos hacer un commit, recuerden añadir todo antes de hacer commit.

```bash
$ git add prueba.txt
$ git commit -m "Añadimos la segunda linea al archivo"
```

Añadir todo primero al staging area nos permite tener un mejor control de a que le estamos haciendo commit, por ejemplo podemos añadir y hacerle commit solo al archivo donde tenemos la bibliografía y no a todo el proyecto donde hay partes no completas.

![Software Carpentry - Version Control with Git](D:/Users/hayde/Documents/R_sites/Computo_Cientifico/img/git-staging-area.svg)


**Ejercicio:** Añadamos una tercera línea al archivo y verifiquemos las diferencias en los archivos, después añadamoslo al staging area y revicemos las diferencias. ¿Qué sucede?

```bash
$ nano prueba.txt
$ git diff
$ git add prueba.txt
$ git diff
```

Al añadirlo al staging area lo estamos añadiendo permanentemente, entonces no hay ninguna diferencia. Si queremos las diferencias con lo último a lo que se le hizo commit podemos hacer lo siguiente:

```bash
$ git diff --staged
```

Ahora hagamos el commit.

```bash
$ git commit -m "Tercera línea para probar que pasa cuando se añade al staging area"
```

Si revisamos el historial, veremos ahora 3 commit diferentes:

```bash
$ git log
```

Cuando el historial es muy grande no nos va a mostrar todo el historial nuestra terminal, para ir avanzando debemos presionar <kbd>Spacebar</kbd> y para salir la letra <kbd>Q</kbd>.  Al presionar <kbd>/</kbd> se puede buscar alguna palabra en los mensajes de los commits. Para limitar la cantidad de información que nos regresa `log` podemos especificar con la opción `-n` la cantidad de commits desde el más reciente. Para ver por ejemplo el último utilizariamos lo siguiente:

```bash
$ git log -1
```

Si queremos ver los mensajes en una sola línea usamos:

```bash
$ git log --oneline
```

Git no guarda información de directorios vacíos. Por ejemplo:

```bash
$ mkdir dic_prueba
$ git status
$ git add dic_prueba
$ git status
```

Si creamos un directorio con archivos, entonces si podemos añadir todos los archivos a la vez y si quedará el registro del directorio también.

```bash
$ git touch dic_prueba/prueba1.txt dic_prueba/prueba2.txt dic_prueba/prueba3.txt
$ git status
$ git add dic_prueba
$ git status
$ git commit -m "Ejemplo de como realizar un registro de directorios con archivos"
```

En algunas ocasiones verán directorios vacíos con un archivo `.gitkeep`, este archivo es solo para que podamos añadir el repo a Git.


**Ejercicio:** Crea un archivo `mi_archivo.txt`, escribe algo en el y guárdalo en la ruta `Mi_primer_repo`. Añádelo a la historia de tu repo. ¿Cuáles son los pasos que debes realizar?

**Ejercicio:** Modifica el archivo `prueba.txt` añadiéndole una línea, ahora en el archivo `mi_archivo.txt` agrega algo y guárdalo. ¿Cómo añadirías los dos archivos al staging área? Añádelos y realiza el commit correspondiente.

**Ejercicio:** Crea un repositorio llamado `bio`. Escribe en un archivo llamado `me.txt` tres líneas de tu biografía, has un commit con tus cambios. Modifica una línea y agrega una cuarta línea. Muestra las diferencias entre el archivo en el staging área y el actual.


## Explorando el historial

A los commits nos podemos referir a ellos con sus identificadores. Al último commit también nos podemos referir como `HEAD`. Añadamos una línea más al archivo `prueba.txt`.

```bash
$ nano prueba.txt
$ cat prueba.txt
```

Ahora, para ver el último cambio con el último commit:

```bash
$ git diff HEAD prueba.txt
```

Si quitamos el HEAD de esa última instrucción veremos lo mismo. Pero si colocamos un `~numero` vamos a ver que nos estamos refiriendo al commit anterior número n. 

```bash
$ git diff HEAD~1 prueba.txt
```

Con `git show` vamos a ver los cambios con respecto a un commit anterior.

```bash
$ git show HEAD~1 prueba.txt
```

También podemos referirnos a los commit por su identificador de números y letras enorme o por los primeros 7 números o letras:

```bash
$ git diff 451b2ad469b96e13547e13dc0e718613acdc987c prueba.txt
$ git diff 451b2ad prueba.txt
```

Revisemos el status:

```bash
$ git status
```

Con la siguiente instrucción podemos regresar las cosas a como estaban antes de hacer el último cambio.

```bash
$ git checkout HEAD prueba.txt
$ cat prueba.txt
```

O podríamos usar uno de los identificadores de commits:

```bash
$ git checkout 451b2ad prueba.txt
$ cat prueba.txt
$ git status
```

Y para regresarlo al último commit de nuevo:

```bash
$ git checkout HEAD prueba.txt
```

El comando `git checkout` revierte los archivos a alguna versión anterior siempre que no lo hayamos añadido al staging área. Para revertir un commit usamos la instrucción `git revert [ID commit]`. Supongamos que tenemos un error en el archivo `prueba.txt` y que ya hicimos commit y queremos revertir al último cambio. Los pasos que haríamos serían los siguientes:

1) `git log` para identificar el ID del commit.

2) Copiar el ID del commit

3) `git revert [ID del commit]` para revertir a ese cambio.

4) Teclear el nuevo mensaje de commit.

5) Guardar y cerrar

Si ya añadimos los cambios al staging área, ya no podemos usar git checkout simplemente. Agregemos una línea al archivo `prueba.txt` y añadamos el cambio al staging área. Usen `git checkout` para ver si podemos revertir el cambio. Veamos que nos dice el status `git status`. Si usamos `git checkout -- prueba.txt` ya no veremos errores pero tampoco se restaurará el archivo. Para hacerlo debemos usar `reset`:

```bash
$ git reset HEAD prueba.txt
```

Y si usamos ahora:

```bash
$ git status
```

Nos indica que ya podemos realizar la modificación con checkout:

```bash
$ git checkout -- prueba.txt
$ git status
```

Para ver tanto las diferencias entre los archivos y los ID de los commits podemos usar lo siguiente:

```bash
$ git log --patch prueba.txt
```

## Ignorar archivos/carpetas

## Github

## Colaboradores

## Crear Ramas

## Actualizando ramas

## Revertir cambios

## Resolver conflictos